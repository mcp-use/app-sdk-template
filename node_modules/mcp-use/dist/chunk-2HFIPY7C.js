import {
  __name
} from "./chunk-SHUYVCID.js";

// src/observability/langfuse.ts
import { config } from "dotenv";

// src/logging.ts
import { createLogger, format, transports } from "winston";
async function getNodeModules() {
  if (typeof process !== "undefined" && process.platform) {
    try {
      const fs = await import("fs");
      const path = await import("path");
      return { fs: fs.default, path: path.default };
    } catch {
      return { fs: null, path: null };
    }
  }
  return { fs: null, path: null };
}
__name(getNodeModules, "getNodeModules");
var { combine, timestamp, label, printf, colorize, splat } = format;
var DEFAULT_LOGGER_NAME = "mcp-use";
function isNodeJSEnvironment() {
  try {
    if (typeof navigator !== "undefined" && navigator.userAgent?.includes("Cloudflare-Workers")) {
      return false;
    }
    if (typeof globalThis.EdgeRuntime !== "undefined" || typeof globalThis.Deno !== "undefined") {
      return false;
    }
    const hasNodeGlobals = typeof process !== "undefined" && typeof process.platform !== "undefined" && typeof __dirname !== "undefined";
    const hasNodeModules = typeof createLogger === "function";
    return hasNodeGlobals && hasNodeModules;
  } catch {
    return false;
  }
}
__name(isNodeJSEnvironment, "isNodeJSEnvironment");
var SimpleConsoleLogger = class {
  static {
    __name(this, "SimpleConsoleLogger");
  }
  _level;
  name;
  constructor(name = DEFAULT_LOGGER_NAME, level = "info") {
    this.name = name;
    this._level = level;
  }
  shouldLog(level) {
    const levels = ["error", "warn", "info", "http", "verbose", "debug", "silly"];
    const currentIndex = levels.indexOf(this._level);
    const messageIndex = levels.indexOf(level);
    return messageIndex <= currentIndex;
  }
  formatMessage(level, message) {
    const timestamp2 = (/* @__PURE__ */ new Date()).toLocaleTimeString("en-US", { hour12: false });
    return `${timestamp2} [${this.name}] ${level}: ${message}`;
  }
  error(message) {
    if (this.shouldLog("error")) {
      console.error(this.formatMessage("error", message));
    }
  }
  warn(message) {
    if (this.shouldLog("warn")) {
      console.warn(this.formatMessage("warn", message));
    }
  }
  info(message) {
    if (this.shouldLog("info")) {
      console.info(this.formatMessage("info", message));
    }
  }
  debug(message) {
    if (this.shouldLog("debug")) {
      console.debug(this.formatMessage("debug", message));
    }
  }
  http(message) {
    if (this.shouldLog("http")) {
      console.log(this.formatMessage("http", message));
    }
  }
  verbose(message) {
    if (this.shouldLog("verbose")) {
      console.log(this.formatMessage("verbose", message));
    }
  }
  silly(message) {
    if (this.shouldLog("silly")) {
      console.log(this.formatMessage("silly", message));
    }
  }
  // Make it compatible with Winston interface
  get level() {
    return this._level;
  }
  set level(newLevel) {
    this._level = newLevel;
  }
};
function resolveLevel(env) {
  const envValue = typeof process !== "undefined" && process.env ? env : void 0;
  switch (envValue?.trim()) {
    case "2":
      return "debug";
    case "1":
      return "info";
    default:
      return "info";
  }
}
__name(resolveLevel, "resolveLevel");
var minimalFormatter = printf(({ level, message, label: label2, timestamp: timestamp2 }) => {
  return `${timestamp2} [${label2}] ${level}: ${message}`;
});
var detailedFormatter = printf(({ level, message, label: label2, timestamp: timestamp2 }) => {
  return `${timestamp2} [${label2}] ${level.toUpperCase()}: ${message}`;
});
var emojiFormatter = printf(({ level, message, label: label2, timestamp: timestamp2 }) => {
  return `${timestamp2} [${label2}] ${level.toUpperCase()}: ${message}`;
});
var Logger = class {
  static {
    __name(this, "Logger");
  }
  static instances = {};
  static simpleInstances = {};
  static currentFormat = "minimal";
  static get(name = DEFAULT_LOGGER_NAME) {
    if (!isNodeJSEnvironment()) {
      if (!this.simpleInstances[name]) {
        const debugEnv = typeof process !== "undefined" && process.env?.DEBUG || void 0;
        this.simpleInstances[name] = new SimpleConsoleLogger(name, resolveLevel(debugEnv));
      }
      return this.simpleInstances[name];
    }
    if (!this.instances[name]) {
      this.instances[name] = createLogger({
        level: resolveLevel(process.env.DEBUG),
        format: combine(
          colorize(),
          splat(),
          label({ label: name }),
          timestamp({ format: "HH:mm:ss" }),
          this.getFormatter()
        ),
        transports: []
      });
    }
    return this.instances[name];
  }
  static getFormatter() {
    switch (this.currentFormat) {
      case "minimal":
        return minimalFormatter;
      case "detailed":
        return detailedFormatter;
      case "emoji":
        return emojiFormatter;
      default:
        return minimalFormatter;
    }
  }
  static async configure(options = {}) {
    const { level, console: console2 = true, file, format: format2 = "minimal" } = options;
    const debugEnv = typeof process !== "undefined" && process.env?.DEBUG || void 0;
    const resolvedLevel = level ?? resolveLevel(debugEnv);
    this.currentFormat = format2;
    const root = this.get();
    root.level = resolvedLevel;
    const winstonRoot = root;
    if (!isNodeJSEnvironment()) {
      Object.values(this.simpleInstances).forEach((logger2) => {
        logger2.level = resolvedLevel;
      });
      return;
    }
    winstonRoot.clear();
    if (console2) {
      winstonRoot.add(new transports.Console());
    }
    if (file) {
      const { fs: nodeFs, path: nodePath } = await getNodeModules();
      if (nodeFs && nodePath) {
        const dir = nodePath.dirname(nodePath.resolve(file));
        if (!nodeFs.existsSync(dir)) {
          nodeFs.mkdirSync(dir, { recursive: true });
        }
        winstonRoot.add(new transports.File({ filename: file }));
      }
    }
    Object.values(this.instances).forEach((logger2) => {
      if (logger2 && "format" in logger2) {
        logger2.level = resolvedLevel;
        logger2.format = combine(
          colorize(),
          splat(),
          label({ label: DEFAULT_LOGGER_NAME }),
          timestamp({ format: "HH:mm:ss" }),
          this.getFormatter()
        );
      }
    });
  }
  static setDebug(enabled) {
    let level;
    if (enabled === 2 || enabled === true)
      level = "debug";
    else if (enabled === 1)
      level = "info";
    else level = "info";
    Object.values(this.simpleInstances).forEach((logger2) => {
      logger2.level = level;
    });
    Object.values(this.instances).forEach((logger2) => {
      if (logger2) {
        logger2.level = level;
      }
    });
    if (typeof process !== "undefined" && process.env) {
      process.env.DEBUG = enabled ? enabled === true ? "2" : String(enabled) : "0";
    }
  }
  static setFormat(format2) {
    this.currentFormat = format2;
    this.configure({ format: format2 });
  }
};
if (isNodeJSEnvironment()) {
  Logger.configure();
} else {
  Logger.configure({ console: true });
}
var logger = Logger.get();

// src/observability/langfuse.ts
config();
var langfuseDisabled = process.env.MCP_USE_LANGFUSE?.toLowerCase() === "false";
var langfuseState = {
  handler: null,
  client: null,
  initPromise: null
};
async function initializeLangfuse(agentId, metadata, metadataProvider, tagsProvider) {
  try {
    const langfuseModule = await import("langfuse-langchain").catch(() => null);
    if (!langfuseModule) {
      logger.debug("Langfuse package not installed - tracing disabled. Install with: npm install langfuse-langchain");
      return;
    }
    const { CallbackHandler } = langfuseModule;
    class LoggingCallbackHandler extends CallbackHandler {
      static {
        __name(this, "LoggingCallbackHandler");
      }
      agentId;
      metadata;
      metadataProvider;
      tagsProvider;
      verbose;
      constructor(config3, agentId2, metadata2, metadataProvider2, tagsProvider2) {
        super(config3);
        this.agentId = agentId2;
        this.metadata = metadata2;
        this.metadataProvider = metadataProvider2;
        this.tagsProvider = tagsProvider2;
        this.verbose = config3?.verbose ?? false;
      }
      // Override to add custom metadata to traces
      async handleChainStart(chain, inputs, runId, parentRunId, tags, metadata2, name, kwargs) {
        logger.debug("Langfuse: Chain start intercepted");
        const customTags = this.getCustomTags();
        const metadataToAdd = this.getMetadata();
        const enhancedTags = [...tags || [], ...customTags];
        const enhancedMetadata = { ...metadata2 || {}, ...metadataToAdd };
        if (this.verbose) {
          logger.debug(`Langfuse: Chain start with custom tags: ${JSON.stringify(enhancedTags)}`);
          logger.debug(`Langfuse: Chain start with metadata: ${JSON.stringify(enhancedMetadata)}`);
        }
        return super.handleChainStart(chain, inputs, runId, parentRunId, enhancedTags, enhancedMetadata, name, kwargs);
      }
      // Get custom tags based on environment and agent configuration
      getCustomTags() {
        const tags = [];
        const env = this.getEnvironmentTag();
        if (env) {
          tags.push(`env:${env}`);
        }
        if (this.agentId) {
          tags.push(`agent_id:${this.agentId}`);
        }
        if (this.tagsProvider) {
          const providerTags = this.tagsProvider();
          if (providerTags && providerTags.length > 0) {
            tags.push(...providerTags);
          }
        }
        return tags;
      }
      // Get metadata
      getMetadata() {
        const metadata2 = {};
        const env = this.getEnvironmentTag();
        if (env) {
          metadata2.env = env;
        }
        if (this.agentId) {
          metadata2.agent_id = this.agentId;
        }
        if (this.metadata) {
          Object.assign(metadata2, this.metadata);
        }
        if (this.metadataProvider) {
          const dynamicMetadata = this.metadataProvider();
          if (dynamicMetadata) {
            Object.assign(metadata2, dynamicMetadata);
          }
        }
        return metadata2;
      }
      // Determine environment tag based on MCP_USE_AGENT_ENV
      getEnvironmentTag() {
        const agentEnv = process.env.MCP_USE_AGENT_ENV;
        if (!agentEnv) {
          return "unknown";
        }
        const envLower = agentEnv.toLowerCase();
        if (envLower === "local" || envLower === "development") {
          return "local";
        } else if (envLower === "production" || envLower === "prod") {
          return "production";
        } else if (envLower === "staging" || envLower === "stage") {
          return "staging";
        } else if (envLower === "hosted" || envLower === "cloud") {
          return "hosted";
        }
        return envLower.replace(/[^a-z0-9_-]/g, "_");
      }
      async handleLLMStart(...args) {
        logger.debug("Langfuse: LLM start intercepted");
        if (this.verbose) {
          logger.debug(`Langfuse: LLM start args: ${JSON.stringify(args)}`);
        }
        return super.handleLLMStart(...args);
      }
      async handleToolStart(...args) {
        logger.debug("Langfuse: Tool start intercepted");
        if (this.verbose) {
          logger.debug(`Langfuse: Tool start args: ${JSON.stringify(args)}`);
        }
        return super.handleToolStart(...args);
      }
      async handleRetrieverStart(...args) {
        logger.debug("Langfuse: Retriever start intercepted");
        if (this.verbose) {
          logger.debug(`Langfuse: Retriever start args: ${JSON.stringify(args)}`);
        }
        return super.handleRetrieverStart(...args);
      }
      async handleAgentAction(...args) {
        logger.debug("Langfuse: Agent action intercepted");
        if (this.verbose) {
          logger.debug(`Langfuse: Agent action args: ${JSON.stringify(args)}`);
        }
        return super.handleAgentAction(...args);
      }
      async handleAgentEnd(...args) {
        logger.debug("Langfuse: Agent end intercepted");
        if (this.verbose) {
          logger.debug(`Langfuse: Agent end args: ${JSON.stringify(args)}`);
        }
        return super.handleAgentEnd(...args);
      }
    }
    const config2 = {
      publicKey: process.env.LANGFUSE_PUBLIC_KEY,
      secretKey: process.env.LANGFUSE_SECRET_KEY,
      baseUrl: process.env.LANGFUSE_HOST || process.env.LANGFUSE_BASEURL || "https://cloud.langfuse.com",
      flushAt: Number.parseInt(process.env.LANGFUSE_FLUSH_AT || "15"),
      flushInterval: Number.parseInt(process.env.LANGFUSE_FLUSH_INTERVAL || "10000"),
      release: process.env.LANGFUSE_RELEASE,
      requestTimeout: Number.parseInt(process.env.LANGFUSE_REQUEST_TIMEOUT || "10000"),
      enabled: process.env.LANGFUSE_ENABLED !== "false"
    };
    langfuseState.handler = new LoggingCallbackHandler(config2, agentId, metadata, metadataProvider, tagsProvider);
    logger.debug("Langfuse observability initialized successfully with logging enabled");
    try {
      const langfuseCore = await import("langfuse").catch(() => null);
      if (langfuseCore) {
        const { Langfuse } = langfuseCore;
        langfuseState.client = new Langfuse({
          publicKey: process.env.LANGFUSE_PUBLIC_KEY,
          secretKey: process.env.LANGFUSE_SECRET_KEY,
          baseUrl: process.env.LANGFUSE_HOST || "https://cloud.langfuse.com"
        });
        logger.debug("Langfuse client initialized");
      }
    } catch (error) {
      logger.debug(`Langfuse client initialization failed: ${error}`);
    }
  } catch (error) {
    logger.debug(`Langfuse initialization error: ${error}`);
  }
}
__name(initializeLangfuse, "initializeLangfuse");
if (langfuseDisabled) {
  logger.debug("Langfuse tracing disabled via MCP_USE_LANGFUSE environment variable");
} else if (!process.env.LANGFUSE_PUBLIC_KEY || !process.env.LANGFUSE_SECRET_KEY) {
  logger.debug(
    "Langfuse API keys not found - tracing disabled. Set LANGFUSE_PUBLIC_KEY and LANGFUSE_SECRET_KEY to enable"
  );
} else {
  langfuseState.initPromise = initializeLangfuse();
}
var langfuseHandler = /* @__PURE__ */ __name(() => langfuseState.handler, "langfuseHandler");
var langfuseClient = /* @__PURE__ */ __name(() => langfuseState.client, "langfuseClient");
var langfuseInitPromise = /* @__PURE__ */ __name(() => langfuseState.initPromise, "langfuseInitPromise");

export {
  Logger,
  logger,
  initializeLangfuse,
  langfuseHandler,
  langfuseClient,
  langfuseInitPromise
};
