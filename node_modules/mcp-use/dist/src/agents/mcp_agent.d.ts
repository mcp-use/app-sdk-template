import type { BaseCallbackHandler } from '@langchain/core/callbacks/base';
import type { BaseLanguageModelInterface } from '@langchain/core/language_models/base';
import type { BaseMessage } from '@langchain/core/messages';
import type { StructuredToolInterface } from '@langchain/core/tools';
import type { StreamEvent } from '@langchain/core/tracers/log_stream';
import type { AgentStep } from 'langchain/agents';
import type { ZodSchema } from 'zod';
import type { MCPClient } from '../client.js';
import type { BaseConnector } from '../connectors/base.js';
import { SystemMessage } from '@langchain/core/messages';
import { LangChainAdapter } from '../adapters/langchain_adapter.js';
import { ServerManager } from '../managers/server_manager.js';
export declare class MCPAgent {
    private llm?;
    private client?;
    private connectors;
    private maxSteps;
    private autoInitialize;
    private memoryEnabled;
    private disallowedTools;
    private additionalTools;
    private useServerManager;
    private verbose;
    private observe;
    private systemPrompt?;
    private systemPromptTemplateOverride?;
    private additionalInstructions?;
    private _initialized;
    private conversationHistory;
    private _agentExecutor;
    private sessions;
    private systemMessage;
    private _tools;
    private adapter;
    private serverManager;
    private telemetry;
    private modelProvider;
    private modelName;
    private observabilityManager;
    private callbacks;
    private metadata;
    private tags;
    private isRemote;
    private remoteAgent;
    constructor(options: {
        llm?: BaseLanguageModelInterface;
        client?: MCPClient;
        connectors?: BaseConnector[];
        maxSteps?: number;
        autoInitialize?: boolean;
        memoryEnabled?: boolean;
        systemPrompt?: string | null;
        systemPromptTemplate?: string | null;
        additionalInstructions?: string | null;
        disallowedTools?: string[];
        additionalTools?: StructuredToolInterface[];
        useServerManager?: boolean;
        verbose?: boolean;
        observe?: boolean;
        adapter?: LangChainAdapter;
        serverManagerFactory?: (client: MCPClient) => ServerManager;
        callbacks?: BaseCallbackHandler[];
        agentId?: string;
        apiKey?: string;
        baseUrl?: string;
    });
    initialize(): Promise<void>;
    private createSystemMessageFromTools;
    private createAgent;
    getConversationHistory(): BaseMessage[];
    clearConversationHistory(): void;
    private addToHistory;
    getSystemMessage(): SystemMessage | null;
    setSystemMessage(message: string): void;
    setDisallowedTools(disallowedTools: string[]): void;
    getDisallowedTools(): string[];
    /**
     * Set metadata for observability traces
     * @param newMetadata - Key-value pairs to add to metadata. Keys should be strings, values should be serializable.
     */
    setMetadata(newMetadata: Record<string, any>): void;
    /**
     * Get current metadata
     * @returns A copy of the current metadata object
     */
    getMetadata(): Record<string, any>;
    /**
     * Set tags for observability traces
     * @param newTags - Array of tag strings to add. Duplicates will be automatically removed.
     */
    setTags(newTags: string[]): void;
    /**
     * Get current tags
     * @returns A copy of the current tags array
     */
    getTags(): string[];
    /**
     * Sanitize metadata to ensure compatibility with observability platforms
     * @param metadata - Raw metadata object
     * @returns Sanitized metadata object
     */
    private sanitizeMetadata;
    /**
     * Sanitize tags to ensure compatibility with observability platforms
     * @param tags - Array of tag strings
     * @returns Array of sanitized tag strings
     */
    private sanitizeTags;
    /**
     * Get MCP server information for observability metadata
     */
    private getMCPServerInfo;
    private _consumeAndReturn;
    /**
     * Runs the agent and returns a promise for the final result.
     */
    run(query: string, maxSteps?: number, manageConnector?: boolean, externalHistory?: BaseMessage[]): Promise<string>;
    /**
     * Runs the agent with structured output and returns a promise for the typed result.
     */
    run<T>(query: string, maxSteps?: number, manageConnector?: boolean, externalHistory?: BaseMessage[], outputSchema?: ZodSchema<T>): Promise<T>;
    /**
     * Runs the agent and yields intermediate steps as an async generator.
     * If outputSchema is provided, returns structured output of type T.
     */
    stream<T = string>(query: string, maxSteps?: number, manageConnector?: boolean, externalHistory?: BaseMessage[], outputSchema?: ZodSchema<T>): AsyncGenerator<AgentStep, string | T, void>;
    close(): Promise<void>;
    /**
     * Yields LangChain StreamEvent objects from the underlying streamEvents() method.
     * This provides token-level streaming and fine-grained event updates.
     */
    streamEvents<T = string>(query: string, maxSteps?: number, manageConnector?: boolean, externalHistory?: BaseMessage[], outputSchema?: ZodSchema<T>): AsyncGenerator<StreamEvent, void, void>;
    /**
     * Attempt to create structured output from raw result with validation and retry logic.
     */
    private _attemptStructuredOutput;
    /**
     * Validate the structured result against the schema with detailed error reporting
     */
    private _validateStructuredResult;
    /**
     * Enhance the query with schema information to make the agent aware of required fields.
     */
    private _enhanceQueryWithSchema;
}
//# sourceMappingURL=mcp_agent.d.ts.map