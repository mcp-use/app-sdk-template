"use strict";
var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __name = (target, value) => __defProp(target, "name", { value, configurable: true });
var __esm = (fn, res) => function __init() {
  return fn && (res = (0, fn[__getOwnPropNames(fn)[0]])(fn = 0)), res;
};
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
));
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// src/logging.ts
async function getNodeModules() {
  if (typeof process !== "undefined" && process.platform) {
    try {
      const fs3 = await import("fs");
      const path3 = await import("path");
      return { fs: fs3.default, path: path3.default };
    } catch {
      return { fs: null, path: null };
    }
  }
  return { fs: null, path: null };
}
function isNodeJSEnvironment() {
  try {
    if (typeof navigator !== "undefined" && navigator.userAgent?.includes("Cloudflare-Workers")) {
      return false;
    }
    if (typeof globalThis.EdgeRuntime !== "undefined" || typeof globalThis.Deno !== "undefined") {
      return false;
    }
    const hasNodeGlobals = typeof process !== "undefined" && typeof process.platform !== "undefined" && typeof __dirname !== "undefined";
    const hasNodeModules = typeof import_winston.createLogger === "function";
    return hasNodeGlobals && hasNodeModules;
  } catch {
    return false;
  }
}
function resolveLevel(env) {
  const envValue = typeof process !== "undefined" && process.env ? env : void 0;
  switch (envValue?.trim()) {
    case "2":
      return "debug";
    case "1":
      return "info";
    default:
      return "info";
  }
}
var import_winston, combine, timestamp, label, printf, colorize, splat, DEFAULT_LOGGER_NAME, SimpleConsoleLogger, minimalFormatter, detailedFormatter, emojiFormatter, Logger, logger;
var init_logging = __esm({
  "src/logging.ts"() {
    "use strict";
    import_winston = require("winston");
    __name(getNodeModules, "getNodeModules");
    ({ combine, timestamp, label, printf, colorize, splat } = import_winston.format);
    DEFAULT_LOGGER_NAME = "mcp-use";
    __name(isNodeJSEnvironment, "isNodeJSEnvironment");
    SimpleConsoleLogger = class {
      static {
        __name(this, "SimpleConsoleLogger");
      }
      _level;
      name;
      constructor(name = DEFAULT_LOGGER_NAME, level = "info") {
        this.name = name;
        this._level = level;
      }
      shouldLog(level) {
        const levels = ["error", "warn", "info", "http", "verbose", "debug", "silly"];
        const currentIndex = levels.indexOf(this._level);
        const messageIndex = levels.indexOf(level);
        return messageIndex <= currentIndex;
      }
      formatMessage(level, message) {
        const timestamp2 = (/* @__PURE__ */ new Date()).toLocaleTimeString("en-US", { hour12: false });
        return `${timestamp2} [${this.name}] ${level}: ${message}`;
      }
      error(message) {
        if (this.shouldLog("error")) {
          console.error(this.formatMessage("error", message));
        }
      }
      warn(message) {
        if (this.shouldLog("warn")) {
          console.warn(this.formatMessage("warn", message));
        }
      }
      info(message) {
        if (this.shouldLog("info")) {
          console.info(this.formatMessage("info", message));
        }
      }
      debug(message) {
        if (this.shouldLog("debug")) {
          console.debug(this.formatMessage("debug", message));
        }
      }
      http(message) {
        if (this.shouldLog("http")) {
          console.log(this.formatMessage("http", message));
        }
      }
      verbose(message) {
        if (this.shouldLog("verbose")) {
          console.log(this.formatMessage("verbose", message));
        }
      }
      silly(message) {
        if (this.shouldLog("silly")) {
          console.log(this.formatMessage("silly", message));
        }
      }
      // Make it compatible with Winston interface
      get level() {
        return this._level;
      }
      set level(newLevel) {
        this._level = newLevel;
      }
    };
    __name(resolveLevel, "resolveLevel");
    minimalFormatter = printf(({ level, message, label: label2, timestamp: timestamp2 }) => {
      return `${timestamp2} [${label2}] ${level}: ${message}`;
    });
    detailedFormatter = printf(({ level, message, label: label2, timestamp: timestamp2 }) => {
      return `${timestamp2} [${label2}] ${level.toUpperCase()}: ${message}`;
    });
    emojiFormatter = printf(({ level, message, label: label2, timestamp: timestamp2 }) => {
      return `${timestamp2} [${label2}] ${level.toUpperCase()}: ${message}`;
    });
    Logger = class {
      static {
        __name(this, "Logger");
      }
      static instances = {};
      static simpleInstances = {};
      static currentFormat = "minimal";
      static get(name = DEFAULT_LOGGER_NAME) {
        if (!isNodeJSEnvironment()) {
          if (!this.simpleInstances[name]) {
            const debugEnv = typeof process !== "undefined" && process.env?.DEBUG || void 0;
            this.simpleInstances[name] = new SimpleConsoleLogger(name, resolveLevel(debugEnv));
          }
          return this.simpleInstances[name];
        }
        if (!this.instances[name]) {
          this.instances[name] = (0, import_winston.createLogger)({
            level: resolveLevel(process.env.DEBUG),
            format: combine(
              colorize(),
              splat(),
              label({ label: name }),
              timestamp({ format: "HH:mm:ss" }),
              this.getFormatter()
            ),
            transports: []
          });
        }
        return this.instances[name];
      }
      static getFormatter() {
        switch (this.currentFormat) {
          case "minimal":
            return minimalFormatter;
          case "detailed":
            return detailedFormatter;
          case "emoji":
            return emojiFormatter;
          default:
            return minimalFormatter;
        }
      }
      static async configure(options = {}) {
        const { level, console: console2 = true, file, format: format2 = "minimal" } = options;
        const debugEnv = typeof process !== "undefined" && process.env?.DEBUG || void 0;
        const resolvedLevel = level ?? resolveLevel(debugEnv);
        this.currentFormat = format2;
        const root = this.get();
        root.level = resolvedLevel;
        const winstonRoot = root;
        if (!isNodeJSEnvironment()) {
          Object.values(this.simpleInstances).forEach((logger2) => {
            logger2.level = resolvedLevel;
          });
          return;
        }
        winstonRoot.clear();
        if (console2) {
          winstonRoot.add(new import_winston.transports.Console());
        }
        if (file) {
          const { fs: nodeFs, path: nodePath } = await getNodeModules();
          if (nodeFs && nodePath) {
            const dir = nodePath.dirname(nodePath.resolve(file));
            if (!nodeFs.existsSync(dir)) {
              nodeFs.mkdirSync(dir, { recursive: true });
            }
            winstonRoot.add(new import_winston.transports.File({ filename: file }));
          }
        }
        Object.values(this.instances).forEach((logger2) => {
          if (logger2 && "format" in logger2) {
            logger2.level = resolvedLevel;
            logger2.format = combine(
              colorize(),
              splat(),
              label({ label: DEFAULT_LOGGER_NAME }),
              timestamp({ format: "HH:mm:ss" }),
              this.getFormatter()
            );
          }
        });
      }
      static setDebug(enabled) {
        let level;
        if (enabled === 2 || enabled === true)
          level = "debug";
        else if (enabled === 1)
          level = "info";
        else level = "info";
        Object.values(this.simpleInstances).forEach((logger2) => {
          logger2.level = level;
        });
        Object.values(this.instances).forEach((logger2) => {
          if (logger2) {
            logger2.level = level;
          }
        });
        if (typeof process !== "undefined" && process.env) {
          process.env.DEBUG = enabled ? enabled === true ? "2" : String(enabled) : "0";
        }
      }
      static setFormat(format2) {
        this.currentFormat = format2;
        this.configure({ format: format2 });
      }
    };
    if (isNodeJSEnvironment()) {
      Logger.configure();
    } else {
      Logger.configure({ console: true });
    }
    logger = Logger.get();
  }
});

// src/observability/langfuse.ts
var langfuse_exports = {};
__export(langfuse_exports, {
  initializeLangfuse: () => initializeLangfuse,
  langfuseClient: () => langfuseClient,
  langfuseHandler: () => langfuseHandler,
  langfuseInitPromise: () => langfuseInitPromise
});
async function initializeLangfuse(agentId, metadata, metadataProvider, tagsProvider) {
  try {
    const langfuseModule = await import("langfuse-langchain").catch(() => null);
    if (!langfuseModule) {
      logger.debug("Langfuse package not installed - tracing disabled. Install with: npm install langfuse-langchain");
      return;
    }
    const { CallbackHandler } = langfuseModule;
    class LoggingCallbackHandler extends CallbackHandler {
      static {
        __name(this, "LoggingCallbackHandler");
      }
      agentId;
      metadata;
      metadataProvider;
      tagsProvider;
      verbose;
      constructor(config3, agentId2, metadata2, metadataProvider2, tagsProvider2) {
        super(config3);
        this.agentId = agentId2;
        this.metadata = metadata2;
        this.metadataProvider = metadataProvider2;
        this.tagsProvider = tagsProvider2;
        this.verbose = config3?.verbose ?? false;
      }
      // Override to add custom metadata to traces
      async handleChainStart(chain, inputs, runId, parentRunId, tags, metadata2, name, kwargs) {
        logger.debug("Langfuse: Chain start intercepted");
        const customTags = this.getCustomTags();
        const metadataToAdd = this.getMetadata();
        const enhancedTags = [...tags || [], ...customTags];
        const enhancedMetadata = { ...metadata2 || {}, ...metadataToAdd };
        if (this.verbose) {
          logger.debug(`Langfuse: Chain start with custom tags: ${JSON.stringify(enhancedTags)}`);
          logger.debug(`Langfuse: Chain start with metadata: ${JSON.stringify(enhancedMetadata)}`);
        }
        return super.handleChainStart(chain, inputs, runId, parentRunId, enhancedTags, enhancedMetadata, name, kwargs);
      }
      // Get custom tags based on environment and agent configuration
      getCustomTags() {
        const tags = [];
        const env = this.getEnvironmentTag();
        if (env) {
          tags.push(`env:${env}`);
        }
        if (this.agentId) {
          tags.push(`agent_id:${this.agentId}`);
        }
        if (this.tagsProvider) {
          const providerTags = this.tagsProvider();
          if (providerTags && providerTags.length > 0) {
            tags.push(...providerTags);
          }
        }
        return tags;
      }
      // Get metadata
      getMetadata() {
        const metadata2 = {};
        const env = this.getEnvironmentTag();
        if (env) {
          metadata2.env = env;
        }
        if (this.agentId) {
          metadata2.agent_id = this.agentId;
        }
        if (this.metadata) {
          Object.assign(metadata2, this.metadata);
        }
        if (this.metadataProvider) {
          const dynamicMetadata = this.metadataProvider();
          if (dynamicMetadata) {
            Object.assign(metadata2, dynamicMetadata);
          }
        }
        return metadata2;
      }
      // Determine environment tag based on MCP_USE_AGENT_ENV
      getEnvironmentTag() {
        const agentEnv = process.env.MCP_USE_AGENT_ENV;
        if (!agentEnv) {
          return "unknown";
        }
        const envLower = agentEnv.toLowerCase();
        if (envLower === "local" || envLower === "development") {
          return "local";
        } else if (envLower === "production" || envLower === "prod") {
          return "production";
        } else if (envLower === "staging" || envLower === "stage") {
          return "staging";
        } else if (envLower === "hosted" || envLower === "cloud") {
          return "hosted";
        }
        return envLower.replace(/[^a-z0-9_-]/g, "_");
      }
      async handleLLMStart(...args) {
        logger.debug("Langfuse: LLM start intercepted");
        if (this.verbose) {
          logger.debug(`Langfuse: LLM start args: ${JSON.stringify(args)}`);
        }
        return super.handleLLMStart(...args);
      }
      async handleToolStart(...args) {
        logger.debug("Langfuse: Tool start intercepted");
        if (this.verbose) {
          logger.debug(`Langfuse: Tool start args: ${JSON.stringify(args)}`);
        }
        return super.handleToolStart(...args);
      }
      async handleRetrieverStart(...args) {
        logger.debug("Langfuse: Retriever start intercepted");
        if (this.verbose) {
          logger.debug(`Langfuse: Retriever start args: ${JSON.stringify(args)}`);
        }
        return super.handleRetrieverStart(...args);
      }
      async handleAgentAction(...args) {
        logger.debug("Langfuse: Agent action intercepted");
        if (this.verbose) {
          logger.debug(`Langfuse: Agent action args: ${JSON.stringify(args)}`);
        }
        return super.handleAgentAction(...args);
      }
      async handleAgentEnd(...args) {
        logger.debug("Langfuse: Agent end intercepted");
        if (this.verbose) {
          logger.debug(`Langfuse: Agent end args: ${JSON.stringify(args)}`);
        }
        return super.handleAgentEnd(...args);
      }
    }
    const config2 = {
      publicKey: process.env.LANGFUSE_PUBLIC_KEY,
      secretKey: process.env.LANGFUSE_SECRET_KEY,
      baseUrl: process.env.LANGFUSE_HOST || process.env.LANGFUSE_BASEURL || "https://cloud.langfuse.com",
      flushAt: Number.parseInt(process.env.LANGFUSE_FLUSH_AT || "15"),
      flushInterval: Number.parseInt(process.env.LANGFUSE_FLUSH_INTERVAL || "10000"),
      release: process.env.LANGFUSE_RELEASE,
      requestTimeout: Number.parseInt(process.env.LANGFUSE_REQUEST_TIMEOUT || "10000"),
      enabled: process.env.LANGFUSE_ENABLED !== "false"
    };
    langfuseState.handler = new LoggingCallbackHandler(config2, agentId, metadata, metadataProvider, tagsProvider);
    logger.debug("Langfuse observability initialized successfully with logging enabled");
    try {
      const langfuseCore = await import("langfuse").catch(() => null);
      if (langfuseCore) {
        const { Langfuse } = langfuseCore;
        langfuseState.client = new Langfuse({
          publicKey: process.env.LANGFUSE_PUBLIC_KEY,
          secretKey: process.env.LANGFUSE_SECRET_KEY,
          baseUrl: process.env.LANGFUSE_HOST || "https://cloud.langfuse.com"
        });
        logger.debug("Langfuse client initialized");
      }
    } catch (error) {
      logger.debug(`Langfuse client initialization failed: ${error}`);
    }
  } catch (error) {
    logger.debug(`Langfuse initialization error: ${error}`);
  }
}
var import_dotenv, langfuseDisabled, langfuseState, langfuseHandler, langfuseClient, langfuseInitPromise;
var init_langfuse = __esm({
  "src/observability/langfuse.ts"() {
    "use strict";
    import_dotenv = require("dotenv");
    init_logging();
    (0, import_dotenv.config)();
    langfuseDisabled = process.env.MCP_USE_LANGFUSE?.toLowerCase() === "false";
    langfuseState = {
      handler: null,
      client: null,
      initPromise: null
    };
    __name(initializeLangfuse, "initializeLangfuse");
    if (langfuseDisabled) {
      logger.debug("Langfuse tracing disabled via MCP_USE_LANGFUSE environment variable");
    } else if (!process.env.LANGFUSE_PUBLIC_KEY || !process.env.LANGFUSE_SECRET_KEY) {
      logger.debug(
        "Langfuse API keys not found - tracing disabled. Set LANGFUSE_PUBLIC_KEY and LANGFUSE_SECRET_KEY to enable"
      );
    } else {
      langfuseState.initPromise = initializeLangfuse();
    }
    langfuseHandler = /* @__PURE__ */ __name(() => langfuseState.handler, "langfuseHandler");
    langfuseClient = /* @__PURE__ */ __name(() => langfuseState.client, "langfuseClient");
    langfuseInitPromise = /* @__PURE__ */ __name(() => langfuseState.initPromise, "langfuseInitPromise");
  }
});

// src/browser.ts
var browser_exports = {};
__export(browser_exports, {
  AIMessage: () => import_messages3.AIMessage,
  BaseAdapter: () => BaseAdapter,
  BaseConnector: () => BaseConnector,
  BaseMessage: () => import_messages3.BaseMessage,
  BrowserOAuthClientProvider: () => BrowserOAuthClientProvider,
  HttpConnector: () => HttpConnector,
  HumanMessage: () => import_messages3.HumanMessage,
  LangChainAdapter: () => LangChainAdapter,
  Logger: () => Logger,
  MCPAgent: () => MCPAgent,
  MCPClient: () => BrowserMCPClient,
  MCPSession: () => MCPSession,
  ObservabilityManager: () => ObservabilityManager,
  RemoteAgent: () => RemoteAgent,
  SystemMessage: () => import_messages3.SystemMessage,
  ToolMessage: () => import_messages3.ToolMessage,
  WebSocketConnector: () => WebSocketConnector,
  createReadableStreamFromGenerator: () => createReadableStreamFromGenerator,
  logger: () => logger,
  onMcpAuthorization: () => onMcpAuthorization,
  streamEventsToAISDK: () => streamEventsToAISDK,
  streamEventsToAISDKWithTools: () => streamEventsToAISDKWithTools
});
module.exports = __toCommonJS(browser_exports);

// src/connectors/http.ts
var import_client = require("@modelcontextprotocol/sdk/client/index.js");
var import_streamableHttp2 = require("@modelcontextprotocol/sdk/client/streamableHttp.js");
init_logging();

// src/task_managers/sse.ts
var import_sse = require("@modelcontextprotocol/sdk/client/sse.js");
init_logging();

// src/task_managers/base.ts
init_logging();
var ConnectionManager = class {
  static {
    __name(this, "ConnectionManager");
  }
  _readyPromise;
  _readyResolver;
  _donePromise;
  _doneResolver;
  _exception = null;
  _connection = null;
  _task = null;
  _abortController = null;
  constructor() {
    this.reset();
  }
  /**
   * Start the connection manager and establish a connection.
   *
   * @returns The established connection.
   * @throws If the connection cannot be established.
   */
  async start() {
    this.reset();
    logger.debug(`Starting ${this.constructor.name}`);
    this._task = this.connectionTask();
    await this._readyPromise;
    if (this._exception) {
      throw this._exception;
    }
    if (this._connection === null) {
      throw new Error("Connection was not established");
    }
    return this._connection;
  }
  /**
   * Stop the connection manager and close the connection.
   */
  async stop() {
    if (this._task && this._abortController) {
      logger.debug(`Cancelling ${this.constructor.name} task`);
      this._abortController.abort();
      try {
        await this._task;
      } catch (e) {
        if (e instanceof Error && e.name === "AbortError") {
          logger.debug(`${this.constructor.name} task aborted successfully`);
        } else {
          logger.warn(`Error stopping ${this.constructor.name} task: ${e}`);
        }
      }
    }
    await this._donePromise;
    logger.debug(`${this.constructor.name} task completed`);
  }
  /**
   * Reset all internal state.
   */
  reset() {
    this._readyPromise = new Promise((res) => this._readyResolver = res);
    this._donePromise = new Promise((res) => this._doneResolver = res);
    this._exception = null;
    this._connection = null;
    this._task = null;
    this._abortController = new AbortController();
  }
  /**
   * The background task responsible for establishing and maintaining the
   * connection until it is cancelled.
   */
  async connectionTask() {
    logger.debug(`Running ${this.constructor.name} task`);
    try {
      this._connection = await this.establishConnection();
      logger.debug(`${this.constructor.name} connected successfully`);
      this._readyResolver();
      await this.waitForAbort();
    } catch (err) {
      this._exception = err;
      logger.error(`Error in ${this.constructor.name} task: ${err}`);
      this._readyResolver();
    } finally {
      if (this._connection !== null) {
        try {
          await this.closeConnection(this._connection);
        } catch (closeErr) {
          logger.warn(`Error closing connection in ${this.constructor.name}: ${closeErr}`);
        }
        this._connection = null;
      }
      this._doneResolver();
    }
  }
  /**
   * Helper that returns a promise which resolves when the abort signal fires.
   */
  async waitForAbort() {
    return new Promise((_resolve, _reject) => {
      if (!this._abortController) {
        return;
      }
      const signal = this._abortController.signal;
      if (signal.aborted) {
        _resolve();
        return;
      }
      const onAbort = /* @__PURE__ */ __name(() => {
        signal.removeEventListener("abort", onAbort);
        _resolve();
      }, "onAbort");
      signal.addEventListener("abort", onAbort);
    });
  }
};

// src/task_managers/sse.ts
var SseConnectionManager = class extends ConnectionManager {
  static {
    __name(this, "SseConnectionManager");
  }
  url;
  opts;
  _transport = null;
  /**
   * Create an SSE connection manager.
   *
   * @param url  The SSE endpoint URL.
   * @param opts Optional transport options (auth, headers, etc.).
   */
  constructor(url, opts) {
    super();
    this.url = typeof url === "string" ? new URL(url) : url;
    this.opts = opts;
  }
  /**
   * Spawn a new `SSEClientTransport` and start the connection.
   */
  async establishConnection() {
    this._transport = new import_sse.SSEClientTransport(this.url, this.opts);
    logger.debug(`${this.constructor.name} connected successfully`);
    return this._transport;
  }
  /**
   * Close the underlying transport and clean up resources.
   */
  async closeConnection(_connection) {
    if (this._transport) {
      try {
        await this._transport.close();
      } catch (e) {
        logger.warn(`Error closing SSE transport: ${e}`);
      } finally {
        this._transport = null;
      }
    }
  }
};

// src/task_managers/streamable_http.ts
var import_streamableHttp = require("@modelcontextprotocol/sdk/client/streamableHttp.js");
init_logging();
var StreamableHttpConnectionManager = class extends ConnectionManager {
  static {
    __name(this, "StreamableHttpConnectionManager");
  }
  url;
  opts;
  _transport = null;
  /**
   * Create a Streamable HTTP connection manager.
   *
   * @param url  The HTTP endpoint URL.
   * @param opts Optional transport options (auth, headers, etc.).
   */
  constructor(url, opts) {
    super();
    this.url = typeof url === "string" ? new URL(url) : url;
    this.opts = opts;
  }
  /**
   * Spawn a new `StreamableHTTPClientTransport` and return it.
   * The Client.connect() method will handle starting the transport.
   */
  async establishConnection() {
    this._transport = new import_streamableHttp.StreamableHTTPClientTransport(this.url, this.opts);
    logger.debug(`${this.constructor.name} created successfully`);
    return this._transport;
  }
  /**
   * Close the underlying transport and clean up resources.
   */
  async closeConnection(_connection) {
    if (this._transport) {
      try {
        await this._transport.close();
      } catch (e) {
        logger.warn(`Error closing Streamable HTTP transport: ${e}`);
      } finally {
        this._transport = null;
      }
    }
  }
  /**
   * Get the session ID from the transport if available.
   */
  get sessionId() {
    return this._transport?.sessionId;
  }
};

// src/connectors/base.ts
init_logging();
var BaseConnector = class {
  static {
    __name(this, "BaseConnector");
  }
  client = null;
  connectionManager = null;
  toolsCache = null;
  connected = false;
  opts;
  constructor(opts = {}) {
    this.opts = opts;
  }
  /** Disconnect and release resources. */
  async disconnect() {
    if (!this.connected) {
      logger.debug("Not connected to MCP implementation");
      return;
    }
    logger.debug("Disconnecting from MCP implementation");
    await this.cleanupResources();
    this.connected = false;
    logger.debug("Disconnected from MCP implementation");
  }
  /** Check if the client is connected */
  get isClientConnected() {
    return this.client != null;
  }
  /**
   * Initialise the MCP session **after** `connect()` has succeeded.
   *
   * In the SDK, `Client.connect(transport)` automatically performs the
   * protocol‑level `initialize` handshake, so we only need to cache the list of
   * tools and expose some server info.
   */
  async initialize(defaultRequestOptions = this.opts.defaultRequestOptions ?? {}) {
    if (!this.client) {
      throw new Error("MCP client is not connected");
    }
    logger.debug("Caching server capabilities & tools");
    const capabilities = this.client.getServerCapabilities();
    const listToolsRes = await this.client.listTools(void 0, defaultRequestOptions);
    this.toolsCache = listToolsRes.tools ?? [];
    logger.debug(`Fetched ${this.toolsCache.length} tools from server`);
    return capabilities;
  }
  /** Lazily expose the cached tools list. */
  get tools() {
    if (!this.toolsCache) {
      throw new Error("MCP client is not initialized; call initialize() first");
    }
    return this.toolsCache;
  }
  /** Call a tool on the server. */
  async callTool(name, args, options) {
    if (!this.client) {
      throw new Error("MCP client is not connected");
    }
    logger.debug(`Calling tool '${name}' with args`, args);
    const res = await this.client.callTool({ name, arguments: args }, void 0, options);
    logger.debug(`Tool '${name}' returned`, res);
    return res;
  }
  /**
   * List resources from the server with optional pagination
   * 
   * @param cursor - Optional cursor for pagination
   * @param options - Request options
   * @returns Resource list with optional nextCursor for pagination
   */
  async listResources(cursor, options) {
    if (!this.client) {
      throw new Error("MCP client is not connected");
    }
    logger.debug("Listing resources", cursor ? `with cursor: ${cursor}` : "");
    return await this.client.listResources({ cursor }, options);
  }
  /**
   * List all resources from the server, automatically handling pagination
   * 
   * @param options - Request options
   * @returns Complete list of all resources
   */
  async listAllResources(options) {
    if (!this.client) {
      throw new Error("MCP client is not connected");
    }
    logger.debug("Listing all resources (with auto-pagination)");
    const allResources = [];
    let cursor = void 0;
    do {
      const result = await this.client.listResources({ cursor }, options);
      allResources.push(...result.resources || []);
      cursor = result.nextCursor;
    } while (cursor);
    return { resources: allResources };
  }
  /**
   * List resource templates from the server
   * 
   * @param options - Request options
   * @returns List of available resource templates
   */
  async listResourceTemplates(options) {
    if (!this.client) {
      throw new Error("MCP client is not connected");
    }
    logger.debug("Listing resource templates");
    return await this.client.listResourceTemplates(void 0, options);
  }
  /** Read a resource by URI. */
  async readResource(uri, options) {
    if (!this.client) {
      throw new Error("MCP client is not connected");
    }
    logger.debug(`Reading resource ${uri}`);
    const res = await this.client.readResource({ uri }, options);
    return { content: res.content, mimeType: res.mimeType };
  }
  /**
   * Subscribe to resource updates
   * 
   * @param uri - URI of the resource to subscribe to
   * @param options - Request options
   */
  async subscribeToResource(uri, options) {
    if (!this.client) {
      throw new Error("MCP client is not connected");
    }
    logger.debug(`Subscribing to resource: ${uri}`);
    return await this.client.subscribeResource({ uri }, options);
  }
  /**
   * Unsubscribe from resource updates
   * 
   * @param uri - URI of the resource to unsubscribe from
   * @param options - Request options
   */
  async unsubscribeFromResource(uri, options) {
    if (!this.client) {
      throw new Error("MCP client is not connected");
    }
    logger.debug(`Unsubscribing from resource: ${uri}`);
    return await this.client.unsubscribeResource({ uri }, options);
  }
  async listPrompts() {
    if (!this.client) {
      throw new Error("MCP client is not connected");
    }
    logger.debug("Listing prompt");
    return await this.client.listPrompts();
  }
  async getPrompt(name, args) {
    if (!this.client) {
      throw new Error("MCP client is not connected");
    }
    logger.debug(`Getting prompt ${name}`);
    return await this.client.getPrompt({ name, arguments: args });
  }
  /** Send a raw request through the client. */
  async request(method, params = null, options) {
    if (!this.client) {
      throw new Error("MCP client is not connected");
    }
    logger.debug(`Sending raw request '${method}' with params`, params);
    return await this.client.request({ method, params: params ?? {} }, void 0, options);
  }
  /**
   * Helper to tear down the client & connection manager safely.
   */
  async cleanupResources() {
    const issues = [];
    if (this.client) {
      try {
        if (typeof this.client.close === "function") {
          await this.client.close();
        }
      } catch (e) {
        const msg = `Error closing client: ${e}`;
        logger.warn(msg);
        issues.push(msg);
      } finally {
        this.client = null;
      }
    }
    if (this.connectionManager) {
      try {
        await this.connectionManager.stop();
      } catch (e) {
        const msg = `Error stopping connection manager: ${e}`;
        logger.warn(msg);
        issues.push(msg);
      } finally {
        this.connectionManager = null;
      }
    }
    this.toolsCache = null;
    if (issues.length) {
      logger.warn(`Resource cleanup finished with ${issues.length} issue(s)`);
    }
  }
};

// src/connectors/http.ts
var HttpConnector = class extends BaseConnector {
  static {
    __name(this, "HttpConnector");
  }
  baseUrl;
  headers;
  timeout;
  sseReadTimeout;
  clientInfo;
  preferSse;
  transportType = null;
  constructor(baseUrl, opts = {}) {
    super(opts);
    this.baseUrl = baseUrl.replace(/\/$/, "");
    this.headers = { ...opts.headers ?? {} };
    if (opts.authToken) {
      this.headers.Authorization = `Bearer ${opts.authToken}`;
    }
    this.timeout = opts.timeout ?? 3e4;
    this.sseReadTimeout = opts.sseReadTimeout ?? 3e5;
    this.clientInfo = opts.clientInfo ?? { name: "http-connector", version: "1.0.0" };
    this.preferSse = opts.preferSse ?? false;
  }
  /** Establish connection to the MCP implementation via HTTP (streamable or SSE). */
  async connect() {
    if (this.connected) {
      logger.debug("Already connected to MCP implementation");
      return;
    }
    const baseUrl = this.baseUrl;
    if (this.preferSse) {
      logger.debug(`Connecting to MCP implementation via HTTP/SSE: ${baseUrl}`);
      await this.connectWithSse(baseUrl);
      return;
    }
    logger.debug(`Connecting to MCP implementation via HTTP: ${baseUrl}`);
    try {
      logger.info("\u{1F504} Attempting streamable HTTP transport...");
      await this.connectWithStreamableHttp(baseUrl);
      logger.info("\u2705 Successfully connected via streamable HTTP");
    } catch (err) {
      let fallbackReason = "Unknown error";
      if (err instanceof import_streamableHttp2.StreamableHTTPError) {
        if (err.code === 400 && err.message.includes("Missing session ID")) {
          fallbackReason = "Server requires session ID (FastMCP compatibility) - using SSE transport";
          logger.warn(`\u26A0\uFE0F  ${fallbackReason}`);
        } else if (err.code === 404 || err.code === 405) {
          fallbackReason = `Server returned ${err.code} - server likely doesn't support streamable HTTP`;
          logger.debug(fallbackReason);
        } else {
          fallbackReason = `Server returned ${err.code}: ${err.message}`;
          logger.debug(fallbackReason);
        }
      } else if (err instanceof Error) {
        const errorStr = err.toString();
        const errorMsg = err.message || "";
        if (errorStr.includes("Missing session ID") || errorStr.includes("Bad Request: Missing session ID") || errorMsg.includes("FastMCP session ID error")) {
          fallbackReason = "Server requires session ID (FastMCP compatibility) - using SSE transport";
          logger.warn(`\u26A0\uFE0F  ${fallbackReason}`);
        } else if (errorStr.includes("405 Method Not Allowed") || errorStr.includes("404 Not Found")) {
          fallbackReason = "Server doesn't support streamable HTTP (405/404)";
          logger.debug(fallbackReason);
        } else {
          fallbackReason = `Streamable HTTP failed: ${err.message}`;
          logger.debug(fallbackReason);
        }
      }
      logger.info("\u{1F504} Falling back to SSE transport...");
      try {
        await this.connectWithSse(baseUrl);
      } catch (sseErr) {
        logger.error(`Failed to connect with both transports:`);
        logger.error(`  Streamable HTTP: ${fallbackReason}`);
        logger.error(`  SSE: ${sseErr}`);
        await this.cleanupResources();
        throw new Error("Could not connect to server with any available transport");
      }
    }
  }
  async connectWithStreamableHttp(baseUrl) {
    try {
      this.connectionManager = new StreamableHttpConnectionManager(
        baseUrl,
        {
          requestInit: {
            headers: this.headers
          },
          // Pass through timeout and other options
          reconnectionOptions: {
            maxReconnectionDelay: 3e4,
            initialReconnectionDelay: 1e3,
            reconnectionDelayGrowFactor: 1.5,
            maxRetries: 2
          }
        }
      );
      const transport = await this.connectionManager.start();
      this.client = new import_client.Client(this.clientInfo, this.opts.clientOptions);
      try {
        await this.client.connect(transport);
      } catch (connectErr) {
        if (connectErr instanceof Error) {
          const errMsg = connectErr.message || connectErr.toString();
          if (errMsg.includes("Missing session ID") || errMsg.includes("Bad Request: Missing session ID")) {
            const wrappedError = new Error(`FastMCP session ID error: ${errMsg}`);
            wrappedError.cause = connectErr;
            throw wrappedError;
          }
        }
        throw connectErr;
      }
      this.connected = true;
      this.transportType = "streamable-http";
      logger.debug(`Successfully connected to MCP implementation via streamable HTTP: ${baseUrl}`);
    } catch (err) {
      await this.cleanupResources();
      throw err;
    }
  }
  async connectWithSse(baseUrl) {
    try {
      this.connectionManager = new SseConnectionManager(
        baseUrl,
        {
          requestInit: {
            headers: this.headers
          }
        }
      );
      const transport = await this.connectionManager.start();
      this.client = new import_client.Client(this.clientInfo, this.opts.clientOptions);
      await this.client.connect(transport);
      this.connected = true;
      this.transportType = "sse";
      logger.debug(`Successfully connected to MCP implementation via HTTP/SSE: ${baseUrl}`);
    } catch (err) {
      await this.cleanupResources();
      throw err;
    }
  }
  get publicIdentifier() {
    return {
      type: "http",
      url: this.baseUrl,
      transport: this.transportType || "unknown"
    };
  }
  /**
   * Get the transport type being used (streamable-http or sse)
   */
  getTransportType() {
    return this.transportType;
  }
};

// src/connectors/websocket.ts
var import_uuid = require("uuid");
init_logging();

// src/task_managers/websocket.ts
var import_ws = __toESM(require("ws"), 1);
init_logging();
var WebSocketConnectionManager = class extends ConnectionManager {
  static {
    __name(this, "WebSocketConnectionManager");
  }
  url;
  headers;
  _ws = null;
  /**
   * @param url     The WebSocket URL to connect to.
   * @param headers Optional headers to include in the connection handshake.
   */
  constructor(url, headers = {}) {
    super();
    this.url = url;
    this.headers = headers;
  }
  /** Establish a WebSocket connection and wait until it is open. */
  async establishConnection() {
    logger.debug(`Connecting to WebSocket: ${this.url}`);
    return new Promise((resolve, reject) => {
      const ws = new import_ws.default(this.url, { headers: this.headers });
      this._ws = ws;
      const onOpen = /* @__PURE__ */ __name(() => {
        cleanup();
        logger.debug("WebSocket connected successfully");
        resolve(ws);
      }, "onOpen");
      const onError = /* @__PURE__ */ __name((err) => {
        cleanup();
        logger.error(`Failed to connect to WebSocket: ${err}`);
        reject(err);
      }, "onError");
      const cleanup = /* @__PURE__ */ __name(() => {
        ws.off("open", onOpen);
        ws.off("error", onError);
      }, "cleanup");
      ws.on("open", onOpen);
      ws.on("error", onError);
    });
  }
  /** Cleanly close the WebSocket connection. */
  async closeConnection(connection) {
    logger.debug("Closing WebSocket connection");
    return new Promise((resolve) => {
      const onClose = /* @__PURE__ */ __name(() => {
        connection.off("close", onClose);
        this._ws = null;
        resolve();
      }, "onClose");
      if (connection.readyState === import_ws.default.CLOSED) {
        onClose();
        return;
      }
      connection.on("close", onClose);
      try {
        connection.close();
      } catch (e) {
        logger.warn(`Error closing WebSocket connection: ${e}`);
        onClose();
      }
    });
  }
};

// src/connectors/websocket.ts
var WebSocketConnector = class extends BaseConnector {
  static {
    __name(this, "WebSocketConnector");
  }
  url;
  headers;
  connectionManager = null;
  ws = null;
  receiverTask = null;
  pending = /* @__PURE__ */ new Map();
  toolsCache = null;
  constructor(url, opts = {}) {
    super();
    this.url = url;
    this.headers = { ...opts.headers ?? {} };
    if (opts.authToken)
      this.headers.Authorization = `Bearer ${opts.authToken}`;
  }
  async connect() {
    if (this.connected) {
      logger.debug("Already connected to MCP implementation");
      return;
    }
    logger.debug(`Connecting via WebSocket: ${this.url}`);
    try {
      this.connectionManager = new WebSocketConnectionManager(this.url, this.headers);
      this.ws = await this.connectionManager.start();
      this.receiverTask = this.receiveLoop();
      this.connected = true;
      logger.debug("WebSocket connected successfully");
    } catch (e) {
      logger.error(`Failed to connect: ${e}`);
      await this.cleanupResources();
      throw e;
    }
  }
  async disconnect() {
    if (!this.connected) {
      logger.debug("Not connected to MCP implementation");
      return;
    }
    logger.debug("Disconnecting \u2026");
    await this.cleanupResources();
    this.connected = false;
  }
  sendRequest(method, params = null) {
    if (!this.ws)
      throw new Error("WebSocket is not connected");
    const id = (0, import_uuid.v4)();
    const payload = JSON.stringify({ id, method, params: params ?? {} });
    return new Promise((resolve, reject) => {
      this.pending.set(id, { resolve, reject });
      this.ws.send(payload, (err) => {
        if (err) {
          this.pending.delete(id);
          reject(err);
        }
      });
    });
  }
  async receiveLoop() {
    if (!this.ws)
      return;
    const socket = this.ws;
    const onMessage = /* @__PURE__ */ __name((msg) => {
      let data;
      try {
        data = JSON.parse(msg.data ?? msg);
      } catch (e) {
        logger.warn("Received non\u2011JSON frame", e);
        return;
      }
      const id = data.id;
      if (id && this.pending.has(id)) {
        const { resolve, reject } = this.pending.get(id);
        this.pending.delete(id);
        if ("result" in data)
          resolve(data.result);
        else if ("error" in data)
          reject(data.error);
      } else {
        logger.debug("Received unsolicited message", data);
      }
    }, "onMessage");
    if (socket.addEventListener) {
      socket.addEventListener("message", onMessage);
    } else {
      socket.on("message", onMessage);
    }
    return new Promise((resolve) => {
      const onClose = /* @__PURE__ */ __name(() => {
        if (socket.removeEventListener) {
          socket.removeEventListener("message", onMessage);
        } else {
          socket.off("message", onMessage);
        }
        this.rejectAll(new Error("WebSocket closed"));
        resolve();
      }, "onClose");
      if (socket.addEventListener) {
        socket.addEventListener("close", onClose);
      } else {
        socket.on("close", onClose);
      }
    });
  }
  rejectAll(err) {
    for (const { reject } of this.pending.values()) reject(err);
    this.pending.clear();
  }
  async initialize() {
    logger.debug("Initializing MCP session over WebSocket");
    const result = await this.sendRequest("initialize");
    const toolsList = await this.listTools();
    this.toolsCache = toolsList.map((t) => t);
    logger.debug(`Initialized with ${this.toolsCache.length} tools`);
    return result;
  }
  async listTools() {
    const res = await this.sendRequest("tools/list");
    return res.tools ?? [];
  }
  async callTool(name, args) {
    return await this.sendRequest("tools/call", { name, arguments: args });
  }
  async listResources() {
    const resources = await this.sendRequest("resources/list");
    return { resources: Array.isArray(resources) ? resources : [] };
  }
  async readResource(uri) {
    const res = await this.sendRequest("resources/read", { uri });
    return { content: res.content, mimeType: res.mimeType };
  }
  async request(method, params = null) {
    return await this.sendRequest(method, params);
  }
  get tools() {
    if (!this.toolsCache)
      throw new Error("MCP client is not initialized");
    return this.toolsCache;
  }
  async cleanupResources() {
    if (this.receiverTask)
      await this.receiverTask.catch(() => {
      });
    this.receiverTask = null;
    this.rejectAll(new Error("WebSocket disconnected"));
    if (this.connectionManager) {
      await this.connectionManager.stop();
      this.connectionManager = null;
      this.ws = null;
    }
    this.toolsCache = null;
  }
  get publicIdentifier() {
    return {
      type: "websocket",
      url: this.url
    };
  }
};

// src/client/base.ts
init_logging();

// src/session.ts
var MCPSession = class {
  static {
    __name(this, "MCPSession");
  }
  connector;
  autoConnect;
  constructor(connector, autoConnect = true) {
    this.connector = connector;
    this.autoConnect = autoConnect;
  }
  async connect() {
    await this.connector.connect();
  }
  async disconnect() {
    await this.connector.disconnect();
  }
  async initialize() {
    if (!this.isConnected && this.autoConnect) {
      await this.connect();
    }
    await this.connector.initialize();
  }
  get isConnected() {
    return this.connector && this.connector.isClientConnected;
  }
};

// src/client/base.ts
var BaseMCPClient = class {
  static {
    __name(this, "BaseMCPClient");
  }
  config = {};
  sessions = {};
  activeSessions = [];
  constructor(config2) {
    if (config2) {
      this.config = config2;
    }
  }
  static fromDict(_cfg) {
    throw new Error("fromDict must be implemented by concrete class");
  }
  addServer(name, serverConfig) {
    this.config.mcpServers = this.config.mcpServers || {};
    this.config.mcpServers[name] = serverConfig;
  }
  removeServer(name) {
    if (this.config.mcpServers?.[name]) {
      delete this.config.mcpServers[name];
      this.activeSessions = this.activeSessions.filter((n) => n !== name);
    }
  }
  getServerNames() {
    return Object.keys(this.config.mcpServers ?? {});
  }
  getServerConfig(name) {
    return this.config.mcpServers?.[name];
  }
  getConfig() {
    return this.config ?? {};
  }
  async createSession(serverName, autoInitialize = true) {
    const servers = this.config.mcpServers ?? {};
    if (Object.keys(servers).length === 0) {
      logger.warn("No MCP servers defined in config");
    }
    if (!servers[serverName]) {
      throw new Error(`Server '${serverName}' not found in config`);
    }
    const connector = this.createConnectorFromConfig(servers[serverName]);
    const session = new MCPSession(connector);
    if (autoInitialize) {
      await session.initialize();
    }
    this.sessions[serverName] = session;
    if (!this.activeSessions.includes(serverName)) {
      this.activeSessions.push(serverName);
    }
    return session;
  }
  async createAllSessions(autoInitialize = true) {
    const servers = this.config.mcpServers ?? {};
    if (Object.keys(servers).length === 0) {
      logger.warn("No MCP servers defined in config");
    }
    for (const name of Object.keys(servers)) {
      await this.createSession(name, autoInitialize);
    }
    return this.sessions;
  }
  getSession(serverName) {
    const session = this.sessions[serverName];
    if (!session) {
      return null;
    }
    return session;
  }
  getAllActiveSessions() {
    return Object.fromEntries(
      this.activeSessions.map((n) => [n, this.sessions[n]])
    );
  }
  async closeSession(serverName) {
    const session = this.sessions[serverName];
    if (!session) {
      logger.warn(`No session exists for server ${serverName}, nothing to close`);
      return;
    }
    try {
      logger.debug(`Closing session for server ${serverName}`);
      await session.disconnect();
    } catch (e) {
      logger.error(`Error closing session for server '${serverName}': ${e}`);
    } finally {
      delete this.sessions[serverName];
      this.activeSessions = this.activeSessions.filter((n) => n !== serverName);
    }
  }
  async closeAllSessions() {
    const serverNames = Object.keys(this.sessions);
    const errors = [];
    for (const serverName of serverNames) {
      try {
        logger.debug(`Closing session for server ${serverName}`);
        await this.closeSession(serverName);
      } catch (e) {
        const errorMsg = `Failed to close session for server '${serverName}': ${e}`;
        logger.error(errorMsg);
        errors.push(errorMsg);
      }
    }
    if (errors.length) {
      logger.error(`Encountered ${errors.length} errors while closing sessions`);
    } else {
      logger.debug("All sessions closed successfully");
    }
  }
};

// src/client/browser.ts
var BrowserMCPClient = class _BrowserMCPClient extends BaseMCPClient {
  static {
    __name(this, "BrowserMCPClient");
  }
  constructor(config2) {
    super(config2);
  }
  static fromDict(cfg) {
    return new _BrowserMCPClient(cfg);
  }
  /**
   * Create a connector from server configuration (Browser version)
   * Supports HTTP and WebSocket connectors only
   */
  createConnectorFromConfig(serverConfig) {
    const { url, transport, headers, authToken } = serverConfig;
    if (!url) {
      throw new Error("Server URL is required");
    }
    const connectorOptions = {
      headers,
      authToken
    };
    if (transport === "websocket" || url.startsWith("ws://") || url.startsWith("wss://")) {
      return new WebSocketConnector(url, connectorOptions);
    } else if (transport === "http" || url.startsWith("http://") || url.startsWith("https://")) {
      return new HttpConnector(url, connectorOptions);
    } else {
      return new HttpConnector(url, connectorOptions);
    }
  }
};

// src/agents/mcp_agent.ts
var import_manager2 = require("@langchain/core/callbacks/manager");
var import_messages2 = require("@langchain/core/messages");
var import_output_parsers = require("@langchain/core/output_parsers");
var import_prompts = require("@langchain/core/prompts");
var import_agents = require("langchain/agents");
var import_zod_to_json_schema2 = require("zod-to-json-schema");

// src/adapters/langchain_adapter.ts
var import_json_schema_to_zod = require("@dmitryrechkin/json-schema-to-zod");
var import_tools = require("@langchain/core/tools");
var import_zod = require("zod");
init_logging();

// src/adapters/base.ts
init_logging();
var BaseAdapter = class {
  static {
    __name(this, "BaseAdapter");
  }
  /**
   * List of tool names that should not be available.
   */
  disallowedTools;
  /**
   * Internal cache that maps a connector instance to the list of tools
   * generated for it.
   */
  connectorToolMap = /* @__PURE__ */ new Map();
  constructor(disallowedTools) {
    this.disallowedTools = disallowedTools ?? [];
  }
  /**
   * Create tools from an MCPClient instance.
   *
   * This is the recommended way to create tools from an MCPClient, as it handles
   * session creation and connector extraction automatically.
   *
   * @param client          The MCPClient to extract tools from.
   * @param disallowedTools Optional list of tool names to exclude.
   * @returns               A promise that resolves with a list of converted tools.
   */
  static async createTools(client, disallowedTools) {
    const adapter = new this(disallowedTools);
    if (!client.activeSessions || Object.keys(client.activeSessions).length === 0) {
      logger.info("No active sessions found, creating new ones...");
      await client.createAllSessions();
    }
    const sessions = client.getAllActiveSessions();
    const connectors = Object.values(sessions).map(
      (session) => session.connector
    );
    return adapter.createToolsFromConnectors(connectors);
  }
  /**
   * Dynamically load tools for a specific connector.
   *
   * @param connector The connector to load tools for.
   * @returns         The list of tools that were loaded in the target framework's format.
   */
  async loadToolsForConnector(connector) {
    if (this.connectorToolMap.has(connector)) {
      const cached = this.connectorToolMap.get(connector);
      logger.debug(`Returning ${cached.length} existing tools for connector`);
      return cached;
    }
    const connectorTools = [];
    const success = await this.ensureConnectorInitialized(connector);
    if (!success) {
      return [];
    }
    for (const tool of connector.tools) {
      const converted = this.convertTool(tool, connector);
      if (converted) {
        connectorTools.push(converted);
      }
    }
    this.connectorToolMap.set(connector, connectorTools);
    logger.debug(
      `Loaded ${connectorTools.length} new tools for connector: ${connectorTools.map((t) => t?.name ?? String(t)).join(", ")}`
    );
    return connectorTools;
  }
  /**
   * Create tools from MCP tools in all provided connectors.
   *
   * @param connectors List of MCP connectors to create tools from.
   * @returns         A promise that resolves with all converted tools.
   */
  async createToolsFromConnectors(connectors) {
    const tools = [];
    for (const connector of connectors) {
      const connectorTools = await this.loadToolsForConnector(connector);
      tools.push(...connectorTools);
    }
    logger.debug(`Available tools: ${tools.length}`);
    return tools;
  }
  /**
   * Check if a connector is initialized and has tools.
   *
   * @param connector The connector to check.
   * @returns         True if the connector is initialized and has tools, false otherwise.
   */
  checkConnectorInitialized(connector) {
    return Boolean(connector.tools && connector.tools.length);
  }
  /**
   * Ensure a connector is initialized.
   *
   * @param connector The connector to initialize.
   * @returns         True if initialization succeeded, false otherwise.
   */
  async ensureConnectorInitialized(connector) {
    if (!this.checkConnectorInitialized(connector)) {
      logger.debug("Connector doesn't have tools, initializing it");
      try {
        await connector.initialize();
        return true;
      } catch (err) {
        logger.error(`Error initializing connector: ${err}`);
        return false;
      }
    }
    return true;
  }
};

// src/adapters/langchain_adapter.ts
function schemaToZod(schema) {
  try {
    return import_json_schema_to_zod.JSONSchemaToZod.convert(schema);
  } catch (err) {
    logger.warn(`Failed to convert JSON schema to Zod: ${err}`);
    return import_zod.z.any();
  }
}
__name(schemaToZod, "schemaToZod");
var LangChainAdapter = class extends BaseAdapter {
  static {
    __name(this, "LangChainAdapter");
  }
  constructor(disallowedTools = []) {
    super(disallowedTools);
  }
  /**
   * Convert a single MCP tool specification into a LangChainJS structured tool.
   */
  convertTool(mcpTool, connector) {
    if (this.disallowedTools.includes(mcpTool.name)) {
      return null;
    }
    const argsSchema = mcpTool.inputSchema ? schemaToZod(mcpTool.inputSchema) : import_zod.z.object({}).optional();
    const tool = new import_tools.DynamicStructuredTool({
      name: mcpTool.name ?? "NO NAME",
      description: mcpTool.description ?? "",
      // Blank is acceptable but discouraged.
      schema: argsSchema,
      func: /* @__PURE__ */ __name(async (input) => {
        logger.debug(`MCP tool "${mcpTool.name}" received input: ${JSON.stringify(input)}`);
        try {
          const result = await connector.callTool(mcpTool.name, input);
          return JSON.stringify(result);
        } catch (err) {
          logger.error(`Error executing MCP tool: ${err.message}`);
          return `Error executing MCP tool: ${String(err)}`;
        }
      }, "func")
    });
    return tool;
  }
};

// src/agents/mcp_agent.ts
init_logging();

// src/managers/server_manager.ts
var import_lodash_es = require("lodash-es");
init_logging();

// src/managers/tools/acquire_active_mcp_server.ts
var import_zod2 = require("zod");

// src/managers/tools/base.ts
var import_tools2 = require("@langchain/core/tools");
var MCPServerTool = class extends import_tools2.StructuredTool {
  static {
    __name(this, "MCPServerTool");
  }
  name = "mcp_server_tool";
  description = "Base tool for MCP server operations.";
  schema;
  _manager;
  constructor(manager) {
    super();
    this._manager = manager;
  }
  async _call(_arg, _runManager, _parentConfig) {
    throw new Error("Method not implemented.");
  }
  get manager() {
    return this._manager;
  }
};

// src/managers/tools/acquire_active_mcp_server.ts
var PresentActiveServerSchema = import_zod2.z.object({});
var AcquireActiveMCPServerTool = class extends MCPServerTool {
  static {
    __name(this, "AcquireActiveMCPServerTool");
  }
  name = "get_active_mcp_server";
  description = "Get the currently active MCP (Model Context Protocol) server";
  schema = PresentActiveServerSchema;
  constructor(manager) {
    super(manager);
  }
  async _call() {
    if (!this.manager.activeServer) {
      return `No MCP server is currently active. Use connect_to_mcp_server to connect to a server.`;
    }
    return `Currently active MCP server: ${this.manager.activeServer}`;
  }
};

// src/managers/tools/add_server_from_config.ts
var import_tools3 = require("langchain/tools");
var import_zod3 = require("zod");
init_logging();
var AddMCPServerFromConfigTool = class extends import_tools3.StructuredTool {
  static {
    __name(this, "AddMCPServerFromConfigTool");
  }
  name = "add_mcp_server_from_config";
  description = "Adds a new MCP server to the client from a configuration object and connects to it, making its tools available.";
  schema = import_zod3.z.object({
    serverName: import_zod3.z.string().describe("The name for the new MCP server."),
    serverConfig: import_zod3.z.any().describe(
      'The configuration object for the server. This should not include the top-level "mcpServers" key.'
    )
  });
  manager;
  constructor(manager) {
    super();
    this.manager = manager;
  }
  async _call({
    serverName,
    serverConfig
  }) {
    try {
      this.manager.client.addServer(serverName, serverConfig);
      let result = `Server '${serverName}' added to the client.`;
      logger.debug(
        `Connecting to new server '${serverName}' and discovering tools.`
      );
      const session = await this.manager.client.createSession(serverName);
      const connector = session.connector;
      const tools = await this.manager.adapter.createToolsFromConnectors([connector]);
      this.manager.serverTools[serverName] = tools;
      this.manager.initializedServers[serverName] = true;
      this.manager.activeServer = serverName;
      const numTools = tools.length;
      result += ` Session created and connected. '${serverName}' is now the active server with ${numTools} tools available.`;
      result += `

${tools.map((t) => t.name).join("\n")}`;
      logger.info(result);
      return result;
    } catch (e) {
      logger.error(
        `Failed to add or connect to server '${serverName}': ${e.message}`
      );
      return `Failed to add or connect to server '${serverName}': ${e.message}`;
    }
  }
};

// src/managers/tools/connect_mcp_server.ts
var import_zod4 = require("zod");
init_logging();
var ConnectMCPServerSchema = import_zod4.z.object({
  serverName: import_zod4.z.string().describe("The name of the MCP server.")
});
var ConnectMCPServerTool = class extends MCPServerTool {
  static {
    __name(this, "ConnectMCPServerTool");
  }
  name = "connect_to_mcp_server";
  description = "Connect to a specific MCP (Model Context Protocol) server to use its tools. Use this tool to connect to a specific server and use its tools.";
  schema = ConnectMCPServerSchema;
  constructor(manager) {
    super(manager);
  }
  async _call({ serverName }) {
    const serverNames = this.manager.client.getServerNames();
    if (!serverNames.includes(serverName)) {
      const available = serverNames.length > 0 ? serverNames.join(", ") : "none";
      return `Server '${serverName}' not found. Available servers: ${available}`;
    }
    if (this.manager.activeServer === serverName) {
      return `Already connected to MCP server '${serverName}'`;
    }
    try {
      let session = this.manager.client.getSession(serverName);
      logger.debug(`Using existing session for server '${serverName}'`);
      if (!session) {
        logger.debug(`Creating new session for server '${serverName}'`);
        session = await this.manager.client.createSession(serverName);
      }
      this.manager.activeServer = serverName;
      if (this.manager.serverTools[serverName]) {
        const connector = session.connector;
        const tools = await this.manager.adapter.createToolsFromConnectors([connector]);
        this.manager.serverTools[serverName] = tools;
        this.manager.initializedServers[serverName] = true;
      }
      const serverTools = this.manager.serverTools[serverName] || [];
      const numTools = serverTools.length;
      return `Connected to MCP server '${serverName}'. ${numTools} tools are now available.`;
    } catch (error) {
      logger.error(`Error connecting to server '${serverName}': ${String(error)}`);
      return `Failed to connect to server '${serverName}': ${String(error)}`;
    }
  }
};

// src/managers/tools/list_mcp_servers.ts
var import_zod5 = require("zod");
init_logging();
var EnumerateServersSchema = import_zod5.z.object({});
var ListMCPServersTool = class extends MCPServerTool {
  static {
    __name(this, "ListMCPServersTool");
  }
  name = "list_mcp_servers";
  description = `Lists all available MCP (Model Context Protocol) servers that can be connected to, along with the tools available on each server. Use this tool to discover servers and see what functionalities they offer.`;
  schema = EnumerateServersSchema;
  constructor(manager) {
    super(manager);
  }
  async _call() {
    const serverNames = this.manager.client.getServerNames();
    if (serverNames.length === 0) {
      return `No MCP servers are currently defined.`;
    }
    const outputLines = ["Available MCP servers:"];
    for (const serverName of serverNames) {
      const isActiveServer = serverName === this.manager.activeServer;
      const activeFlag = isActiveServer ? " (ACTIVE)" : "";
      outputLines.push(`- ${serverName}${activeFlag}`);
      try {
        const serverTools = this.manager.serverTools?.[serverName] ?? [];
        const numberOfTools = Array.isArray(serverTools) ? serverTools.length : 0;
        outputLines.push(`${numberOfTools} tools available for this server
`);
      } catch (error) {
        logger.error(`Unexpected error listing tools for server '${serverName}': ${String(error)}`);
      }
    }
    return outputLines.join("\n");
  }
};

// src/managers/tools/release_mcp_server_connection.ts
var import_zod6 = require("zod");
var ReleaseConnectionSchema = import_zod6.z.object({});
var ReleaseMCPServerConnectionTool = class extends MCPServerTool {
  static {
    __name(this, "ReleaseMCPServerConnectionTool");
  }
  name = "disconnect_from_mcp_server";
  description = "Disconnect from the currently active MCP (Model Context Protocol) server";
  schema = ReleaseConnectionSchema;
  constructor(manager) {
    super(manager);
  }
  async _call() {
    if (!this.manager.activeServer) {
      return `No MCP server is currently active, so there's nothing to disconnect from.`;
    }
    const serverName = this.manager.activeServer;
    this.manager.activeServer = null;
    return `Successfully disconnected from MCP server '${serverName}'.`;
  }
};

// src/managers/server_manager.ts
var ServerManager = class {
  static {
    __name(this, "ServerManager");
  }
  initializedServers = {};
  serverTools = {};
  client;
  adapter;
  activeServer = null;
  overrideManagementTools;
  constructor(client, adapter, managementTools) {
    this.client = client;
    this.adapter = adapter;
    this.overrideManagementTools = managementTools;
  }
  setManagementTools(tools) {
    this.overrideManagementTools = tools;
    logger.info(
      `Overriding default management tools with a new set of ${tools.length} tools.`
    );
  }
  logState(context) {
    const allServerNames = this.client.getServerNames();
    const activeSessionNames = Object.keys(this.client.getAllActiveSessions());
    if (allServerNames.length === 0) {
      logger.info("Server Manager State: No servers configured.");
      return;
    }
    const tableData = allServerNames.map((name) => ({
      "Server Name": name,
      "Connected": activeSessionNames.includes(name) ? "\u2705" : "\u274C",
      "Initialized": this.initializedServers[name] ? "\u2705" : "\u274C",
      "Tool Count": this.serverTools[name]?.length ?? 0,
      "Active": this.activeServer === name ? "\u2705" : "\u274C"
    }));
    logger.info(`Server Manager State: [${context}]`);
    console.table(tableData);
  }
  initialize() {
    const serverNames = this.client.getServerNames?.();
    if (serverNames.length === 0) {
      logger.warn("No MCP servers defined in client configuration");
    }
  }
  async prefetchServerTools() {
    const servers = this.client.getServerNames();
    for (const serverName of servers) {
      try {
        let session = null;
        session = this.client.getSession(serverName);
        logger.debug(`Using existing session for server '${serverName}' to prefetch tools.`);
        if (!session) {
          session = await this.client.createSession(serverName).catch((createSessionError) => {
            logger.warn(`Could not create session for '${serverName}' during prefetch: ${createSessionError}`);
            return null;
          });
          logger.debug(`Temporarily created session for '${serverName}' to prefetch tools.`);
        }
        if (session) {
          const connector = session.connector;
          let tools = [];
          try {
            tools = await this.adapter.createToolsFromConnectors([connector]);
          } catch (toolFetchError) {
            logger.error(`Failed to create tools from connector for server '${serverName}': ${toolFetchError}`);
            continue;
          }
          const cachedTools = this.serverTools[serverName];
          const toolsChanged = !cachedTools || !(0, import_lodash_es.isEqual)(cachedTools, tools);
          if (toolsChanged) {
            this.serverTools[serverName] = tools;
            this.initializedServers[serverName] = true;
            logger.debug(`Prefetched ${tools.length} tools for server '${serverName}'.`);
          } else {
            logger.debug(
              `Tools for server '${serverName}' unchanged, using cached version.`
            );
          }
        }
      } catch (outerError) {
        logger.error(`Error prefetching tools for server '${serverName}': ${outerError}`);
      }
    }
  }
  get tools() {
    if (logger.level === "debug") {
      this.logState("Providing tools to agent");
    }
    const managementTools = this.overrideManagementTools ?? [
      new AddMCPServerFromConfigTool(this),
      new ListMCPServersTool(this),
      new ConnectMCPServerTool(this),
      new AcquireActiveMCPServerTool(this),
      new ReleaseMCPServerConnectionTool(this)
    ];
    if (this.activeServer && this.serverTools[this.activeServer]) {
      const activeTools = this.serverTools[this.activeServer];
      logger.debug(
        `Adding ${activeTools.length} tools from active server '${this.activeServer}'`
      );
      return [...managementTools, ...activeTools];
    }
    return managementTools;
  }
};

// src/observability/index.ts
init_langfuse();
init_langfuse();

// src/observability/manager.ts
init_logging();
var ObservabilityManager = class {
  static {
    __name(this, "ObservabilityManager");
  }
  customCallbacks;
  availableHandlers = [];
  handlerNames = [];
  initialized = false;
  verbose;
  observe;
  agentId;
  metadata;
  metadataProvider;
  tagsProvider;
  constructor(config2 = {}) {
    this.customCallbacks = config2.customCallbacks;
    this.verbose = config2.verbose ?? false;
    this.observe = config2.observe ?? true;
    this.agentId = config2.agentId;
    this.metadata = config2.metadata;
    this.metadataProvider = config2.metadataProvider;
    this.tagsProvider = config2.tagsProvider;
  }
  /**
   * Collect all available observability handlers from configured platforms.
   */
  async collectAvailableHandlers() {
    if (this.initialized) {
      return;
    }
    try {
      const { langfuseHandler: langfuseHandler2, langfuseInitPromise: langfuseInitPromise2 } = await Promise.resolve().then(() => (init_langfuse(), langfuse_exports));
      if (this.agentId || this.metadata || this.metadataProvider || this.tagsProvider) {
        const { initializeLangfuse: initializeLangfuse2 } = await Promise.resolve().then(() => (init_langfuse(), langfuse_exports));
        await initializeLangfuse2(this.agentId, this.metadata, this.metadataProvider, this.tagsProvider);
        logger.debug(`ObservabilityManager: Reinitialized Langfuse with agent ID: ${this.agentId}, metadata: ${JSON.stringify(this.metadata)}`);
      } else {
        const initPromise = langfuseInitPromise2();
        if (initPromise) {
          await initPromise;
        }
      }
      const handler = langfuseHandler2();
      if (handler) {
        this.availableHandlers.push(handler);
        this.handlerNames.push("Langfuse");
        logger.debug("ObservabilityManager: Langfuse handler available");
      }
    } catch {
      logger.debug("ObservabilityManager: Langfuse module not available");
    }
    this.initialized = true;
  }
  /**
   * Get the list of callbacks to use.
   * @returns List of callbacks - either custom callbacks if provided, or all available observability handlers.
   */
  async getCallbacks() {
    if (!this.observe) {
      logger.debug("ObservabilityManager: Observability disabled via observe=false");
      return [];
    }
    if (this.customCallbacks) {
      logger.debug(`ObservabilityManager: Using ${this.customCallbacks.length} custom callbacks`);
      return this.customCallbacks;
    }
    await this.collectAvailableHandlers();
    if (this.availableHandlers.length > 0) {
      logger.debug(`ObservabilityManager: Using ${this.availableHandlers.length} handlers`);
    } else {
      logger.debug("ObservabilityManager: No callbacks configured");
    }
    return this.availableHandlers;
  }
  /**
   * Get the names of available handlers.
   * @returns List of handler names (e.g., ["Langfuse", "Laminar"])
   */
  async getHandlerNames() {
    if (!this.observe) {
      return [];
    }
    if (this.customCallbacks) {
      return this.customCallbacks.map((cb) => cb.constructor.name);
    }
    await this.collectAvailableHandlers();
    return this.handlerNames;
  }
  /**
   * Check if any callbacks are available.
   * @returns True if callbacks are available, False otherwise.
   */
  async hasCallbacks() {
    if (!this.observe) {
      return false;
    }
    const callbacks = await this.getCallbacks();
    return callbacks.length > 0;
  }
  /**
   * Add a callback to the custom callbacks list.
   * @param callback The callback to add.
   */
  addCallback(callback) {
    if (!this.customCallbacks) {
      this.customCallbacks = [];
    }
    this.customCallbacks.push(callback);
    logger.debug(`ObservabilityManager: Added custom callback: ${callback.constructor.name}`);
  }
  /**
   * Clear all custom callbacks.
   */
  clearCallbacks() {
    this.customCallbacks = [];
    logger.debug("ObservabilityManager: Cleared all custom callbacks");
  }
  /**
   * Flush all pending traces to observability platforms.
   * Important for serverless environments and short-lived processes.
   */
  async flush() {
    const callbacks = await this.getCallbacks();
    for (const callback of callbacks) {
      if ("flushAsync" in callback && typeof callback.flushAsync === "function") {
        await callback.flushAsync();
      }
    }
    logger.debug("ObservabilityManager: All traces flushed");
  }
  /**
   * Shutdown all handlers gracefully (for serverless environments).
   */
  async shutdown() {
    await this.flush();
    const callbacks = await this.getCallbacks();
    for (const callback of callbacks) {
      if ("shutdownAsync" in callback && typeof callback.shutdownAsync === "function") {
        await callback.shutdownAsync();
      } else if ("shutdown" in callback && typeof callback.shutdown === "function") {
        await callback.shutdown();
      }
    }
    logger.debug("ObservabilityManager: All handlers shutdown");
  }
  /**
   * String representation of the ObservabilityManager.
   */
  toString() {
    const names = this.handlerNames;
    if (names.length > 0) {
      return `ObservabilityManager(handlers=${names.join(", ")})`;
    }
    return "ObservabilityManager(no handlers)";
  }
};

// src/telemetry/telemetry.ts
var fs2 = __toESM(require("fs"), 1);
var os = __toESM(require("os"), 1);
var path2 = __toESM(require("path"), 1);
var import_posthog_node = require("posthog-node");
var import_uuid2 = require("uuid");
init_logging();

// src/telemetry/events.ts
var BaseTelemetryEvent = class {
  static {
    __name(this, "BaseTelemetryEvent");
  }
};
var MCPAgentExecutionEvent = class extends BaseTelemetryEvent {
  constructor(data) {
    super();
    this.data = data;
  }
  static {
    __name(this, "MCPAgentExecutionEvent");
  }
  get name() {
    return "mcp_agent_execution";
  }
  get properties() {
    return {
      // Core execution info
      execution_method: this.data.executionMethod,
      query: this.data.query,
      query_length: this.data.query.length,
      success: this.data.success,
      // Agent configuration
      model_provider: this.data.modelProvider,
      model_name: this.data.modelName,
      server_count: this.data.serverCount,
      server_identifiers: this.data.serverIdentifiers,
      total_tools_available: this.data.totalToolsAvailable,
      tools_available_names: this.data.toolsAvailableNames,
      max_steps_configured: this.data.maxStepsConfigured,
      memory_enabled: this.data.memoryEnabled,
      use_server_manager: this.data.useServerManager,
      // Execution parameters (always include, even if null)
      max_steps_used: this.data.maxStepsUsed,
      manage_connector: this.data.manageConnector,
      external_history_used: this.data.externalHistoryUsed,
      // Execution results (always include, even if null)
      steps_taken: this.data.stepsTaken ?? null,
      tools_used_count: this.data.toolsUsedCount ?? null,
      tools_used_names: this.data.toolsUsedNames ?? null,
      response: this.data.response ?? null,
      response_length: this.data.response ? this.data.response.length : null,
      execution_time_ms: this.data.executionTimeMs ?? null,
      error_type: this.data.errorType ?? null,
      conversation_history_length: this.data.conversationHistoryLength ?? null
    };
  }
};

// src/telemetry/utils.ts
var fs = __toESM(require("fs"), 1);
var path = __toESM(require("path"), 1);
function getPackageVersion() {
  try {
    if (typeof __dirname === "undefined" || typeof fs === "undefined") {
      return "unknown";
    }
    const packagePath = path.join(__dirname, "../../package.json");
    const packageJson = JSON.parse(fs.readFileSync(packagePath, "utf-8"));
    return packageJson.version || "unknown";
  } catch {
    return "unknown";
  }
}
__name(getPackageVersion, "getPackageVersion");
function getModelProvider(llm) {
  return llm._llm_type || llm.constructor.name.toLowerCase();
}
__name(getModelProvider, "getModelProvider");
function getModelName(llm) {
  if ("_identifyingParams" in llm) {
    const identifyingParams = llm._identifyingParams;
    if (typeof identifyingParams === "object" && identifyingParams !== null) {
      for (const key of ["model", "modelName", "model_name", "modelId", "model_id", "deploymentName", "deployment_name"]) {
        if (key in identifyingParams) {
          return String(identifyingParams[key]);
        }
      }
    }
  }
  return llm.model || llm.modelName || llm.constructor.name;
}
__name(getModelName, "getModelName");
function extractModelInfo(llm) {
  return [getModelProvider(llm), getModelName(llm)];
}
__name(extractModelInfo, "extractModelInfo");

// src/telemetry/telemetry.ts
function isNodeJSEnvironment2() {
  try {
    if (typeof navigator !== "undefined" && navigator.userAgent?.includes("Cloudflare-Workers")) {
      return false;
    }
    if (typeof globalThis.EdgeRuntime !== "undefined" || typeof globalThis.Deno !== "undefined") {
      return false;
    }
    const hasNodeGlobals = typeof process !== "undefined" && typeof process.platform !== "undefined" && typeof __dirname !== "undefined";
    const hasNodeModules = typeof fs2 !== "undefined" && typeof os !== "undefined" && typeof fs2.existsSync === "function";
    return hasNodeGlobals && hasNodeModules;
  } catch {
    return false;
  }
}
__name(isNodeJSEnvironment2, "isNodeJSEnvironment");
var ScarfEventLogger = class {
  static {
    __name(this, "ScarfEventLogger");
  }
  endpoint;
  timeout;
  constructor(endpoint, timeout = 3e3) {
    this.endpoint = endpoint;
    this.timeout = timeout;
  }
  async logEvent(properties) {
    try {
      const controller = new AbortController();
      const timeoutId = setTimeout(() => controller.abort(), this.timeout);
      const response = await fetch(this.endpoint, {
        method: "POST",
        headers: {
          "Content-Type": "application/json"
        },
        body: JSON.stringify(properties),
        signal: controller.signal
      });
      clearTimeout(timeoutId);
      if (!response.ok) {
        throw new Error(`HTTP error! status: ${response.status}`);
      }
    } catch (error) {
      logger.debug(`Failed to send Scarf event: ${error}`);
    }
  }
};
function getCacheHome() {
  if (!isNodeJSEnvironment2()) {
    return "/tmp/mcp_use_cache";
  }
  const envVar = process.env.XDG_CACHE_HOME;
  if (envVar && path2.isAbsolute(envVar)) {
    return envVar;
  }
  const platform = process.platform;
  const homeDir = os.homedir();
  if (platform === "win32") {
    const appdata = process.env.LOCALAPPDATA || process.env.APPDATA;
    if (appdata) {
      return appdata;
    }
    return path2.join(homeDir, "AppData", "Local");
  } else if (platform === "darwin") {
    return path2.join(homeDir, "Library", "Caches");
  } else {
    return path2.join(homeDir, ".cache");
  }
}
__name(getCacheHome, "getCacheHome");
var Telemetry = class _Telemetry {
  static {
    __name(this, "Telemetry");
  }
  static instance = null;
  USER_ID_PATH = path2.join(getCacheHome(), "mcp_use_3", "telemetry_user_id");
  VERSION_DOWNLOAD_PATH = path2.join(getCacheHome(), "mcp_use", "download_version");
  PROJECT_API_KEY = "phc_lyTtbYwvkdSbrcMQNPiKiiRWrrM1seyKIMjycSvItEI";
  HOST = "https://eu.i.posthog.com";
  SCARF_GATEWAY_URL = "https://mcpuse.gateway.scarf.sh/events-ts";
  UNKNOWN_USER_ID = "UNKNOWN_USER_ID";
  _currUserId = null;
  _posthogClient = null;
  _scarfClient = null;
  _source = "typescript";
  constructor() {
    const isNodeJS = isNodeJSEnvironment2();
    const telemetryDisabled = typeof process !== "undefined" && process.env?.MCP_USE_ANONYMIZED_TELEMETRY?.toLowerCase() === "false" || false;
    this._source = typeof process !== "undefined" && process.env?.MCP_USE_TELEMETRY_SOURCE || "typescript";
    if (telemetryDisabled) {
      this._posthogClient = null;
      this._scarfClient = null;
      logger.debug("Telemetry disabled via environment variable");
    } else if (!isNodeJS) {
      this._posthogClient = null;
      this._scarfClient = null;
      logger.debug("Telemetry disabled - non-Node.js environment detected (e.g., Cloudflare Workers)");
    } else {
      logger.info("Anonymized telemetry enabled. Set MCP_USE_ANONYMIZED_TELEMETRY=false to disable.");
      try {
        this._posthogClient = new import_posthog_node.PostHog(
          this.PROJECT_API_KEY,
          {
            host: this.HOST,
            disableGeoip: false
          }
        );
      } catch (e) {
        logger.warn(`Failed to initialize PostHog telemetry: ${e}`);
        this._posthogClient = null;
      }
      try {
        this._scarfClient = new ScarfEventLogger(this.SCARF_GATEWAY_URL, 3e3);
      } catch (e) {
        logger.warn(`Failed to initialize Scarf telemetry: ${e}`);
        this._scarfClient = null;
      }
    }
  }
  static getInstance() {
    if (!_Telemetry.instance) {
      _Telemetry.instance = new _Telemetry();
    }
    return _Telemetry.instance;
  }
  /**
   * Set the source identifier for telemetry events.
   * This allows tracking usage from different applications.
   * @param source - The source identifier (e.g., "my-app", "cli", "vs-code-extension")
   */
  setSource(source) {
    this._source = source;
    logger.debug(`Telemetry source set to: ${source}`);
  }
  /**
   * Get the current source identifier.
   */
  getSource() {
    return this._source;
  }
  get userId() {
    if (this._currUserId) {
      return this._currUserId;
    }
    if (!isNodeJSEnvironment2()) {
      this._currUserId = this.UNKNOWN_USER_ID;
      return this._currUserId;
    }
    try {
      const isFirstTime = !fs2.existsSync(this.USER_ID_PATH);
      if (isFirstTime) {
        logger.debug(`Creating user ID path: ${this.USER_ID_PATH}`);
        fs2.mkdirSync(path2.dirname(this.USER_ID_PATH), { recursive: true });
        const newUserId = (0, import_uuid2.v4)();
        fs2.writeFileSync(this.USER_ID_PATH, newUserId);
        this._currUserId = newUserId;
        logger.debug(`User ID path created: ${this.USER_ID_PATH}`);
      } else {
        this._currUserId = fs2.readFileSync(this.USER_ID_PATH, "utf-8").trim();
      }
      this.trackPackageDownload({
        triggered_by: "user_id_property"
      }).catch((e) => logger.debug(`Failed to track package download: ${e}`));
    } catch (e) {
      logger.debug(`Failed to get/create user ID: ${e}`);
      this._currUserId = this.UNKNOWN_USER_ID;
    }
    return this._currUserId;
  }
  async capture(event) {
    if (!this._posthogClient && !this._scarfClient) {
      return;
    }
    if (this._posthogClient) {
      try {
        const properties = { ...event.properties };
        properties.mcp_use_version = getPackageVersion();
        properties.language = "typescript";
        properties.source = this._source;
        this._posthogClient.capture({
          distinctId: this.userId,
          event: event.name,
          properties
        });
      } catch (e) {
        logger.debug(`Failed to track PostHog event ${event.name}: ${e}`);
      }
    }
    if (this._scarfClient) {
      try {
        const properties = {};
        properties.mcp_use_version = getPackageVersion();
        properties.user_id = this.userId;
        properties.event = event.name;
        properties.language = "typescript";
        properties.source = this._source;
        await this._scarfClient.logEvent(properties);
      } catch (e) {
        logger.debug(`Failed to track Scarf event ${event.name}: ${e}`);
      }
    }
  }
  async trackPackageDownload(properties) {
    if (!this._scarfClient) {
      return;
    }
    if (!isNodeJSEnvironment2()) {
      return;
    }
    try {
      const currentVersion = getPackageVersion();
      let shouldTrack = false;
      let firstDownload = false;
      if (!fs2.existsSync(this.VERSION_DOWNLOAD_PATH)) {
        shouldTrack = true;
        firstDownload = true;
        fs2.mkdirSync(path2.dirname(this.VERSION_DOWNLOAD_PATH), { recursive: true });
        fs2.writeFileSync(this.VERSION_DOWNLOAD_PATH, currentVersion);
      } else {
        const savedVersion = fs2.readFileSync(this.VERSION_DOWNLOAD_PATH, "utf-8").trim();
        if (currentVersion > savedVersion) {
          shouldTrack = true;
          firstDownload = false;
          fs2.writeFileSync(this.VERSION_DOWNLOAD_PATH, currentVersion);
        }
      }
      if (shouldTrack) {
        logger.debug(`Tracking package download event with properties: ${JSON.stringify(properties)}`);
        const eventProperties = { ...properties || {} };
        eventProperties.mcp_use_version = currentVersion;
        eventProperties.user_id = this.userId;
        eventProperties.event = "package_download";
        eventProperties.first_download = firstDownload;
        eventProperties.language = "typescript";
        eventProperties.source = this._source;
        await this._scarfClient.logEvent(eventProperties);
      }
    } catch (e) {
      logger.debug(`Failed to track Scarf package_download event: ${e}`);
    }
  }
  async trackAgentExecution(data) {
    const event = new MCPAgentExecutionEvent(data);
    await this.capture(event);
  }
  flush() {
    if (this._posthogClient) {
      try {
        this._posthogClient.flush();
        logger.debug("PostHog client telemetry queue flushed");
      } catch (e) {
        logger.debug(`Failed to flush PostHog client: ${e}`);
      }
    }
    if (this._scarfClient) {
      logger.debug("Scarf telemetry events sent immediately (no flush needed)");
    }
  }
  shutdown() {
    if (this._posthogClient) {
      try {
        this._posthogClient.shutdown();
        logger.debug("PostHog client shutdown successfully");
      } catch (e) {
        logger.debug(`Error shutting down PostHog client: ${e}`);
      }
    }
    if (this._scarfClient) {
      logger.debug("Scarf telemetry client shutdown (no action needed)");
    }
  }
};

// src/agents/prompts/system_prompt_builder.ts
var import_messages = require("@langchain/core/messages");
function generateToolDescriptions(tools, disallowedTools) {
  const disallowedSet = new Set(disallowedTools ?? []);
  const descriptions = [];
  for (const tool of tools) {
    if (disallowedSet.has(tool.name))
      continue;
    const escaped = tool.description.replace(/\{/g, "{{").replace(/\}/g, "}}");
    descriptions.push(`- ${tool.name}: ${escaped}`);
  }
  return descriptions;
}
__name(generateToolDescriptions, "generateToolDescriptions");
function buildSystemPromptContent(template, toolDescriptionLines, additionalInstructions) {
  const block = toolDescriptionLines.join("\n");
  let content;
  if (template.includes("{tool_descriptions}")) {
    content = template.replace("{tool_descriptions}", block);
  } else {
    console.warn("`{tool_descriptions}` placeholder not found; appending at end.");
    content = `${template}

Available tools:
${block}`;
  }
  if (additionalInstructions) {
    content += `

${additionalInstructions}`;
  }
  return content;
}
__name(buildSystemPromptContent, "buildSystemPromptContent");
function createSystemMessage(tools, systemPromptTemplate, serverManagerTemplate, useServerManager, disallowedTools, userProvidedPrompt, additionalInstructions) {
  if (userProvidedPrompt) {
    return new import_messages.SystemMessage({ content: userProvidedPrompt });
  }
  const template = useServerManager ? serverManagerTemplate : systemPromptTemplate;
  const toolLines = generateToolDescriptions(tools, disallowedTools);
  const finalContent = buildSystemPromptContent(
    template,
    toolLines,
    additionalInstructions
  );
  return new import_messages.SystemMessage({ content: finalContent });
}
__name(createSystemMessage, "createSystemMessage");

// src/agents/prompts/templates.ts
var DEFAULT_SYSTEM_PROMPT_TEMPLATE = `You are a helpful AI assistant.
You have access to the following tools:

{tool_descriptions}

Use the following format:

Question: the input question you must answer
Thought: you should always think about what to do
Action: the action to take, should be one of the available tools
Action Input: the input to the action
Observation: the result of the action
... (this Thought/Action/Action Input/Observation can repeat N times)
Thought: I now know the final answer
Final Answer: the final answer to the original input question`;
var SERVER_MANAGER_SYSTEM_PROMPT_TEMPLATE = `You are a helpful assistant designed to interact with MCP
 (Model Context Protocol) servers. You can manage connections to different servers and use the tools
 provided by the currently active server.

Important: The available tools change depending on which server is active.
If a request requires tools not listed below (e.g., file operations, web browsing,
 image manipulation), you MUST first connect to the appropriate server using
 'connect_to_mcp_server'.
Use 'list_mcp_servers' to find the relevant server if you are unsure.
Only after successfully connecting and seeing the new tools listed in
the response should you attempt to use those server-specific tools.
Before attempting a task that requires specific tools, you should
ensure you are connected to the correct server and aware of its
available tools. If unsure, use 'list_mcp_servers' to see options
or 'get_active_mcp_server' to check the current connection.

When you connect to a server using 'connect_to_mcp_server',
 you will be informed about the new tools that become available.
You can then use these server-specific tools in subsequent steps.

Here are the tools *currently* available to you (this list includes server management tools and will
 change when you connect to a server):
{tool_descriptions}
`;

// src/agents/remote.ts
var import_zod_to_json_schema = require("zod-to-json-schema");
init_logging();
var API_CHATS_ENDPOINT = "/api/v1/chats";
var API_CHAT_EXECUTE_ENDPOINT = "/api/v1/chats/{chat_id}/execute";
var RemoteAgent = class {
  static {
    __name(this, "RemoteAgent");
  }
  agentId;
  apiKey;
  baseUrl;
  chatId = null;
  constructor(options) {
    this.agentId = options.agentId;
    this.baseUrl = options.baseUrl ?? "https://cloud.mcp-use.com";
    const apiKey = options.apiKey ?? process.env.MCP_USE_API_KEY;
    if (!apiKey) {
      throw new Error(
        "API key is required for remote execution. Please provide it as a parameter or set the MCP_USE_API_KEY environment variable. You can get an API key from https://cloud.mcp-use.com"
      );
    }
    this.apiKey = apiKey;
  }
  pydanticToJsonSchema(schema) {
    return (0, import_zod_to_json_schema.zodToJsonSchema)(schema);
  }
  parseStructuredResponse(responseData, outputSchema) {
    let resultData;
    if (typeof responseData === "object" && responseData !== null) {
      if ("result" in responseData) {
        const outerResult = responseData.result;
        if (typeof outerResult === "object" && outerResult !== null && "result" in outerResult) {
          resultData = outerResult.result;
        } else {
          resultData = outerResult;
        }
      } else {
        resultData = responseData;
      }
    } else if (typeof responseData === "string") {
      try {
        resultData = JSON.parse(responseData);
      } catch {
        resultData = { content: responseData };
      }
    } else {
      resultData = responseData;
    }
    try {
      return outputSchema.parse(resultData);
    } catch (e) {
      logger.warn(`Failed to parse structured output: ${e}`);
      const schemaShape = outputSchema._def?.shape();
      if (schemaShape && "content" in schemaShape) {
        return outputSchema.parse({ content: String(resultData) });
      }
      throw e;
    }
  }
  async createChatSession() {
    const chatPayload = {
      title: `Remote Agent Session - ${this.agentId}`,
      agent_id: this.agentId,
      type: "agent_execution"
    };
    const headers = {
      "Content-Type": "application/json",
      "x-api-key": this.apiKey
    };
    const chatUrl = `${this.baseUrl}${API_CHATS_ENDPOINT}`;
    logger.info(`\u{1F4DD} Creating chat session for agent ${this.agentId}`);
    try {
      const response = await fetch(chatUrl, {
        method: "POST",
        headers,
        body: JSON.stringify(chatPayload)
      });
      if (!response.ok) {
        const responseText = await response.text();
        const statusCode = response.status;
        if (statusCode === 404) {
          throw new Error(
            `Agent not found: Agent '${this.agentId}' does not exist or you don't have access to it. Please verify the agent ID and ensure it exists in your account.`
          );
        }
        throw new Error(`Failed to create chat session: ${statusCode} - ${responseText}`);
      }
      const chatData = await response.json();
      const chatId = chatData.id;
      logger.info(`\u2705 Chat session created: ${chatId}`);
      return chatId;
    } catch (e) {
      if (e instanceof Error) {
        throw new TypeError(`Failed to create chat session: ${e.message}`);
      }
      throw new Error(`Failed to create chat session: ${String(e)}`);
    }
  }
  async run(query, maxSteps, manageConnector, externalHistory, outputSchema) {
    if (externalHistory !== void 0) {
      logger.warn("External history is not yet supported for remote execution");
    }
    try {
      logger.info(`\u{1F310} Executing query on remote agent ${this.agentId}`);
      if (this.chatId === null) {
        this.chatId = await this.createChatSession();
      }
      const chatId = this.chatId;
      const executionPayload = {
        query,
        max_steps: maxSteps ?? 10
      };
      if (outputSchema) {
        executionPayload.output_schema = this.pydanticToJsonSchema(outputSchema);
        logger.info(`\u{1F527} Using structured output with schema`);
      }
      const headers = {
        "Content-Type": "application/json",
        "x-api-key": this.apiKey
      };
      const executionUrl = `${this.baseUrl}${API_CHAT_EXECUTE_ENDPOINT.replace("{chat_id}", chatId)}`;
      logger.info(`\u{1F680} Executing agent in chat ${chatId}`);
      const response = await fetch(executionUrl, {
        method: "POST",
        headers,
        body: JSON.stringify(executionPayload),
        signal: AbortSignal.timeout(3e5)
        // 5 minute timeout
      });
      if (!response.ok) {
        const responseText = await response.text();
        const statusCode = response.status;
        if (statusCode === 401) {
          logger.error(`\u274C Authentication failed: ${responseText}`);
          throw new Error(
            "Authentication failed: Invalid or missing API key. Please check your API key and ensure the MCP_USE_API_KEY environment variable is set correctly."
          );
        } else if (statusCode === 403) {
          logger.error(`\u274C Access forbidden: ${responseText}`);
          throw new Error(
            `Access denied: You don't have permission to execute agent '${this.agentId}'. Check if the agent exists and you have the necessary permissions.`
          );
        } else if (statusCode === 404) {
          logger.error(`\u274C Agent not found: ${responseText}`);
          throw new Error(
            `Agent not found: Agent '${this.agentId}' does not exist or you don't have access to it. Please verify the agent ID and ensure it exists in your account.`
          );
        } else if (statusCode === 422) {
          logger.error(`\u274C Validation error: ${responseText}`);
          throw new Error(
            `Request validation failed: ${responseText}. Please check your query parameters and output schema format.`
          );
        } else if (statusCode === 500) {
          logger.error(`\u274C Server error: ${responseText}`);
          throw new Error(
            "Internal server error occurred during agent execution. Please try again later or contact support if the issue persists."
          );
        } else {
          logger.error(`\u274C Remote execution failed with status ${statusCode}: ${responseText}`);
          throw new Error(`Remote agent execution failed: ${statusCode} - ${responseText}`);
        }
      }
      const result = await response.json();
      logger.info(`\u{1F527} Response: ${JSON.stringify(result)}`);
      logger.info("\u2705 Remote execution completed successfully");
      if (typeof result === "object" && result !== null) {
        if (result.status === "error" || result.error !== null) {
          const errorMsg = result.error ?? String(result);
          logger.error(`\u274C Remote agent execution failed: ${errorMsg}`);
          throw new Error(`Remote agent execution failed: ${errorMsg}`);
        }
        if (String(result).includes("failed to initialize")) {
          logger.error(`\u274C Agent initialization failed: ${result}`);
          throw new Error(
            `Agent initialization failed on remote server. This usually indicates:
\u2022 Invalid agent configuration (LLM model, system prompt)
\u2022 Missing or invalid MCP server configurations
\u2022 Network connectivity issues with MCP servers
\u2022 Missing environment variables or credentials
Raw error: ${result}`
          );
        }
      }
      if (outputSchema) {
        return this.parseStructuredResponse(result, outputSchema);
      }
      if (typeof result === "object" && result !== null && "result" in result) {
        return result.result;
      } else if (typeof result === "string") {
        return result;
      } else {
        return String(result);
      }
    } catch (e) {
      if (e instanceof Error) {
        if (e.name === "AbortError") {
          logger.error(`\u274C Remote execution timed out: ${e}`);
          throw new Error(
            "Remote agent execution timed out. The server may be overloaded or the query is taking too long to process. Try again or use a simpler query."
          );
        }
        logger.error(`\u274C Remote execution error: ${e}`);
        throw new Error(`Remote agent execution failed: ${e.message}`);
      }
      logger.error(`\u274C Remote execution error: ${e}`);
      throw new Error(`Remote agent execution failed: ${String(e)}`);
    }
  }
  // eslint-disable-next-line require-yield
  async *stream(query, maxSteps, manageConnector, externalHistory, outputSchema) {
    const result = await this.run(query, maxSteps, manageConnector, externalHistory, outputSchema);
    return result;
  }
  async close() {
    logger.info("\u{1F50C} Remote agent client closed");
  }
};

// src/agents/mcp_agent.ts
var MCPAgent = class {
  static {
    __name(this, "MCPAgent");
  }
  llm;
  client;
  connectors;
  maxSteps;
  autoInitialize;
  memoryEnabled;
  disallowedTools;
  additionalTools;
  useServerManager;
  verbose;
  observe;
  systemPrompt;
  systemPromptTemplateOverride;
  additionalInstructions;
  _initialized = false;
  conversationHistory = [];
  _agentExecutor = null;
  sessions = {};
  systemMessage = null;
  _tools = [];
  adapter;
  serverManager = null;
  telemetry;
  modelProvider;
  modelName;
  // Observability support
  observabilityManager;
  callbacks = [];
  metadata = {};
  tags = [];
  // Remote agent support
  isRemote = false;
  remoteAgent = null;
  constructor(options) {
    if (options.agentId) {
      this.isRemote = true;
      this.remoteAgent = new RemoteAgent({
        agentId: options.agentId,
        apiKey: options.apiKey,
        baseUrl: options.baseUrl
      });
      this.maxSteps = options.maxSteps ?? 5;
      this.memoryEnabled = options.memoryEnabled ?? true;
      this.autoInitialize = options.autoInitialize ?? false;
      this.verbose = options.verbose ?? false;
      this.observe = options.observe ?? true;
      this.connectors = [];
      this.disallowedTools = [];
      this.additionalTools = [];
      this.useServerManager = false;
      this.adapter = new LangChainAdapter();
      this.telemetry = Telemetry.getInstance();
      this.modelProvider = "remote";
      this.modelName = "remote-agent";
      this.observabilityManager = new ObservabilityManager({
        customCallbacks: options.callbacks,
        agentId: options.agentId
      });
      this.callbacks = [];
      return;
    }
    if (!options.llm) {
      throw new Error("llm is required for local execution. For remote execution, provide agentId instead.");
    }
    this.llm = options.llm;
    this.client = options.client;
    this.connectors = options.connectors ?? [];
    this.maxSteps = options.maxSteps ?? 5;
    this.autoInitialize = options.autoInitialize ?? false;
    this.memoryEnabled = options.memoryEnabled ?? true;
    this.systemPrompt = options.systemPrompt ?? null;
    this.systemPromptTemplateOverride = options.systemPromptTemplate ?? null;
    this.additionalInstructions = options.additionalInstructions ?? null;
    this.disallowedTools = options.disallowedTools ?? [];
    this.additionalTools = options.additionalTools ?? [];
    this.useServerManager = options.useServerManager ?? false;
    this.verbose = options.verbose ?? false;
    this.observe = options.observe ?? true;
    if (!this.client && this.connectors.length === 0) {
      throw new Error("Either 'client' or at least one 'connector' must be provided.");
    }
    if (this.useServerManager) {
      if (!this.client) {
        throw new Error("'client' must be provided when 'useServerManager' is true.");
      }
      this.adapter = options.adapter ?? new LangChainAdapter(this.disallowedTools);
      this.serverManager = options.serverManagerFactory?.(this.client) ?? new ServerManager(this.client, this.adapter);
    } else {
      this.adapter = options.adapter ?? new LangChainAdapter(this.disallowedTools);
    }
    this.telemetry = Telemetry.getInstance();
    if (this.llm) {
      const [provider, name] = extractModelInfo(this.llm);
      this.modelProvider = provider;
      this.modelName = name;
    } else {
      this.modelProvider = "unknown";
      this.modelName = "unknown";
    }
    this.observabilityManager = new ObservabilityManager({
      customCallbacks: options.callbacks,
      verbose: this.verbose,
      observe: this.observe,
      agentId: options.agentId,
      metadataProvider: /* @__PURE__ */ __name(() => this.getMetadata(), "metadataProvider"),
      tagsProvider: /* @__PURE__ */ __name(() => this.getTags(), "tagsProvider")
    });
    Object.defineProperty(this, "agentExecutor", {
      get: /* @__PURE__ */ __name(() => this._agentExecutor, "get"),
      configurable: true
    });
    Object.defineProperty(this, "tools", {
      get: /* @__PURE__ */ __name(() => this._tools, "get"),
      configurable: true
    });
    Object.defineProperty(this, "initialized", {
      get: /* @__PURE__ */ __name(() => this._initialized, "get"),
      configurable: true
    });
  }
  async initialize() {
    if (this.isRemote) {
      this._initialized = true;
      return;
    }
    logger.info("\u{1F680} Initializing MCP agent and connecting to services...");
    this.callbacks = await this.observabilityManager.getCallbacks();
    const handlerNames = await this.observabilityManager.getHandlerNames();
    if (handlerNames.length > 0) {
      logger.info(`\u{1F4CA} Observability enabled with: ${handlerNames.join(", ")}`);
    }
    if (this.useServerManager && this.serverManager) {
      await this.serverManager.initialize();
      const managementTools = this.serverManager.tools;
      this._tools = managementTools;
      this._tools.push(...this.additionalTools);
      logger.info(
        `\u{1F527} Server manager mode active with ${managementTools.length} management tools`
      );
      await this.createSystemMessageFromTools(this._tools);
    } else {
      if (this.client) {
        this.sessions = this.client.getAllActiveSessions();
        logger.info(`\u{1F50C} Found ${Object.keys(this.sessions).length} existing sessions`);
        if (Object.keys(this.sessions).length === 0) {
          logger.info("\u{1F504} No active sessions found, creating new ones...");
          this.sessions = await this.client.createAllSessions();
          logger.info(`\u2705 Created ${Object.keys(this.sessions).length} new sessions`);
        }
        this._tools = await LangChainAdapter.createTools(this.client);
        this._tools.push(...this.additionalTools);
        logger.info(`\u{1F6E0}\uFE0F Created ${this._tools.length} LangChain tools from client`);
      } else {
        logger.info(`\u{1F517} Connecting to ${this.connectors.length} direct connectors...`);
        for (const connector of this.connectors) {
          if (!connector.isClientConnected) {
            await connector.connect();
          }
        }
        this._tools = await this.adapter.createToolsFromConnectors(this.connectors);
        this._tools.push(...this.additionalTools);
        logger.info(`\u{1F6E0}\uFE0F Created ${this._tools.length} LangChain tools from connectors`);
      }
      logger.info(`\u{1F9F0} Found ${this._tools.length} tools across all connectors`);
      await this.createSystemMessageFromTools(this._tools);
    }
    this._agentExecutor = this.createAgent();
    this._initialized = true;
    const mcpServerInfo = this.getMCPServerInfo();
    if (Object.keys(mcpServerInfo).length > 0) {
      this.setMetadata(mcpServerInfo);
      logger.debug(`MCP server info added to metadata: ${JSON.stringify(mcpServerInfo)}`);
    }
    logger.info("\u2728 Agent initialization complete");
  }
  async createSystemMessageFromTools(tools) {
    const systemPromptTemplate = this.systemPromptTemplateOverride ?? DEFAULT_SYSTEM_PROMPT_TEMPLATE;
    this.systemMessage = createSystemMessage(
      tools,
      systemPromptTemplate,
      SERVER_MANAGER_SYSTEM_PROMPT_TEMPLATE,
      this.useServerManager,
      this.disallowedTools,
      this.systemPrompt ?? void 0,
      this.additionalInstructions ?? void 0
    );
    if (this.memoryEnabled) {
      this.conversationHistory = [
        this.systemMessage,
        ...this.conversationHistory.filter((m) => !(m instanceof import_messages2.SystemMessage))
      ];
    }
  }
  createAgent() {
    if (!this.llm) {
      throw new Error("LLM is required to create agent");
    }
    const systemContent = this.systemMessage?.content ?? "You are a helpful assistant.";
    const prompt = import_prompts.ChatPromptTemplate.fromMessages([
      ["system", systemContent],
      new import_prompts.MessagesPlaceholder("chat_history"),
      ["human", "{input}"],
      new import_prompts.MessagesPlaceholder("agent_scratchpad")
    ]);
    const agent = (0, import_agents.createToolCallingAgent)({
      llm: this.llm,
      tools: this._tools,
      prompt
    });
    return new import_agents.AgentExecutor({
      agent,
      tools: this._tools,
      maxIterations: this.maxSteps,
      verbose: this.verbose,
      returnIntermediateSteps: true,
      callbacks: this.callbacks
    });
  }
  getConversationHistory() {
    return [...this.conversationHistory];
  }
  clearConversationHistory() {
    this.conversationHistory = this.memoryEnabled && this.systemMessage ? [this.systemMessage] : [];
  }
  addToHistory(message) {
    if (this.memoryEnabled)
      this.conversationHistory.push(message);
  }
  getSystemMessage() {
    return this.systemMessage;
  }
  setSystemMessage(message) {
    this.systemMessage = new import_messages2.SystemMessage(message);
    if (this.memoryEnabled) {
      this.conversationHistory = this.conversationHistory.filter((m) => !(m instanceof import_messages2.SystemMessage));
      this.conversationHistory.unshift(this.systemMessage);
    }
    if (this._initialized && this._tools.length) {
      this._agentExecutor = this.createAgent();
      logger.debug("Agent recreated with new system message");
    }
  }
  setDisallowedTools(disallowedTools) {
    this.disallowedTools = disallowedTools;
    this.adapter = new LangChainAdapter(this.disallowedTools);
    if (this._initialized) {
      logger.debug("Agent already initialized. Changes will take effect on next initialization.");
    }
  }
  getDisallowedTools() {
    return this.disallowedTools;
  }
  /**
   * Set metadata for observability traces
   * @param newMetadata - Key-value pairs to add to metadata. Keys should be strings, values should be serializable.
   */
  setMetadata(newMetadata) {
    const sanitizedMetadata = this.sanitizeMetadata(newMetadata);
    this.metadata = { ...this.metadata, ...sanitizedMetadata };
    logger.debug(`Metadata set: ${JSON.stringify(this.metadata)}`);
  }
  /**
   * Get current metadata
   * @returns A copy of the current metadata object
   */
  getMetadata() {
    return { ...this.metadata };
  }
  /**
   * Set tags for observability traces
   * @param newTags - Array of tag strings to add. Duplicates will be automatically removed.
   */
  setTags(newTags) {
    const sanitizedTags = this.sanitizeTags(newTags);
    this.tags = [.../* @__PURE__ */ new Set([...this.tags, ...sanitizedTags])];
    logger.debug(`Tags set: ${JSON.stringify(this.tags)}`);
  }
  /**
   * Get current tags
   * @returns A copy of the current tags array
   */
  getTags() {
    return [...this.tags];
  }
  /**
   * Sanitize metadata to ensure compatibility with observability platforms
   * @param metadata - Raw metadata object
   * @returns Sanitized metadata object
   */
  sanitizeMetadata(metadata) {
    const sanitized = {};
    for (const [key, value] of Object.entries(metadata)) {
      if (typeof key !== "string" || key.length === 0) {
        logger.warn(`Invalid metadata key: ${key}. Skipping.`);
        continue;
      }
      const sanitizedKey = key.replace(/[^\w-]/g, "_");
      if (value === null || value === void 0) {
        sanitized[sanitizedKey] = value;
      } else if (typeof value === "string" || typeof value === "number" || typeof value === "boolean") {
        sanitized[sanitizedKey] = value;
      } else if (Array.isArray(value)) {
        const sanitizedArray = value.filter(
          (item) => typeof item === "string" || typeof item === "number" || typeof item === "boolean"
        );
        if (sanitizedArray.length > 0) {
          sanitized[sanitizedKey] = sanitizedArray;
        }
      } else if (typeof value === "object") {
        try {
          const serialized = JSON.stringify(value);
          if (serialized.length > 1e3) {
            logger.warn(`Metadata value for key '${sanitizedKey}' is too large. Truncating.`);
            sanitized[sanitizedKey] = `${serialized.substring(0, 1e3)}...`;
          } else {
            sanitized[sanitizedKey] = value;
          }
        } catch (error) {
          logger.warn(`Failed to serialize metadata value for key '${sanitizedKey}': ${error}. Skipping.`);
        }
      } else {
        logger.warn(`Unsupported metadata value type for key '${sanitizedKey}': ${typeof value}. Skipping.`);
      }
    }
    return sanitized;
  }
  /**
   * Sanitize tags to ensure compatibility with observability platforms
   * @param tags - Array of tag strings
   * @returns Array of sanitized tag strings
   */
  sanitizeTags(tags) {
    return tags.filter((tag) => typeof tag === "string" && tag.length > 0).map((tag) => tag.replace(/[^\w:-]/g, "_")).filter((tag) => tag.length <= 50);
  }
  /**
   * Get MCP server information for observability metadata
   */
  getMCPServerInfo() {
    const serverInfo = {};
    try {
      if (this.client) {
        const serverNames = this.client.getServerNames();
        serverInfo.mcp_servers_count = serverNames.length;
        serverInfo.mcp_server_names = serverNames;
        const serverConfigs = {};
        for (const serverName of serverNames) {
          try {
            const config2 = this.client.getServerConfig(serverName);
            if (config2) {
              let serverType = "unknown";
              if (config2.command) {
                serverType = "command";
              } else if (config2.url) {
                serverType = "http";
              } else if (config2.ws_url) {
                serverType = "websocket";
              }
              serverConfigs[serverName] = {
                type: serverType,
                // Include safe configuration details (avoid sensitive data)
                has_args: !!config2.args,
                has_env: !!config2.env,
                has_headers: !!config2.headers,
                url: config2.url || null,
                command: config2.command || null
              };
            }
          } catch (error) {
            logger.warn(`Failed to get config for server '${serverName}': ${error}`);
            serverConfigs[serverName] = { type: "error", error: "config_unavailable" };
          }
        }
        serverInfo.mcp_server_configs = serverConfigs;
      } else if (this.connectors && this.connectors.length > 0) {
        serverInfo.mcp_servers_count = this.connectors.length;
        serverInfo.mcp_server_names = this.connectors.map((c) => c.publicIdentifier);
        serverInfo.mcp_server_types = this.connectors.map((c) => c.constructor.name);
      }
    } catch (error) {
      logger.warn(`Failed to collect MCP server info: ${error}`);
      serverInfo.error = "collection_failed";
    }
    return serverInfo;
  }
  async _consumeAndReturn(generator) {
    while (true) {
      const { done, value } = await generator.next();
      if (done) {
        return value;
      }
    }
  }
  async run(query, maxSteps, manageConnector, externalHistory, outputSchema) {
    if (this.isRemote && this.remoteAgent) {
      return this.remoteAgent.run(query, maxSteps, manageConnector, externalHistory, outputSchema);
    }
    const generator = this.stream(
      query,
      maxSteps,
      manageConnector,
      externalHistory,
      outputSchema
    );
    return this._consumeAndReturn(generator);
  }
  /**
   * Runs the agent and yields intermediate steps as an async generator.
   * If outputSchema is provided, returns structured output of type T.
   */
  async *stream(query, maxSteps, manageConnector = true, externalHistory, outputSchema) {
    if (this.isRemote && this.remoteAgent) {
      const result2 = await this.remoteAgent.run(query, maxSteps, manageConnector, externalHistory, outputSchema);
      return result2;
    }
    let result = "";
    let initializedHere = false;
    const startTime = Date.now();
    const toolsUsedNames = [];
    let stepsTaken = 0;
    const structuredOutputSuccess = false;
    const structuredOutputSuccessRef = { value: structuredOutputSuccess };
    let structuredLlm = null;
    let schemaDescription = "";
    if (outputSchema) {
      query = this._enhanceQueryWithSchema(query, outputSchema);
      logger.debug(`\u{1F504} Structured output requested, schema: ${JSON.stringify((0, import_zod_to_json_schema2.zodToJsonSchema)(outputSchema), null, 2)}`);
      if (this.llm && "withStructuredOutput" in this.llm && typeof this.llm.withStructuredOutput === "function") {
        structuredLlm = this.llm.withStructuredOutput(outputSchema);
      } else if (this.llm) {
        structuredLlm = this.llm;
      } else {
        throw new Error("LLM is required for structured output");
      }
      schemaDescription = JSON.stringify((0, import_zod_to_json_schema2.zodToJsonSchema)(outputSchema), null, 2);
    }
    try {
      if (manageConnector && !this._initialized) {
        await this.initialize();
        initializedHere = true;
      } else if (!this._initialized && this.autoInitialize) {
        await this.initialize();
        initializedHere = true;
      }
      if (!this._agentExecutor) {
        throw new Error("MCP agent failed to initialize");
      }
      const steps = maxSteps ?? this.maxSteps;
      this._agentExecutor.maxIterations = steps;
      const display_query = query.length > 50 ? `${query.slice(0, 50).replace(/\n/g, " ")}...` : query.replace(/\n/g, " ");
      logger.info(`\u{1F4AC} Received query: '${display_query}'`);
      if (this.memoryEnabled) {
        this.addToHistory(new import_messages2.HumanMessage(query));
      }
      const historyToUse = externalHistory ?? this.conversationHistory;
      const langchainHistory = [];
      for (const msg of historyToUse) {
        if (msg instanceof import_messages2.HumanMessage || msg instanceof import_messages2.AIMessage) {
          langchainHistory.push(msg);
        }
      }
      const intermediateSteps = [];
      const inputs = { input: query, chat_history: langchainHistory };
      let nameToToolMap = Object.fromEntries(this._tools.map((t) => [t.name, t]));
      logger.info(`\u{1F3C1} Starting agent execution with max_steps=${steps}`);
      let runManager;
      if (this.callbacks?.length > 0) {
        const callbackManager = new import_manager2.CallbackManager(void 0, {
          handlers: this.callbacks,
          inheritableHandlers: this.callbacks
        });
        runManager = await callbackManager.handleChainStart({
          name: "MCPAgent (mcp-use)",
          id: ["MCPAgent (mcp-use)"],
          lc: 1,
          type: "not_implemented"
        }, inputs);
      }
      for (let stepNum = 0; stepNum < steps; stepNum++) {
        stepsTaken = stepNum + 1;
        if (this.useServerManager && this.serverManager) {
          const currentTools = this.serverManager.tools;
          const currentToolNames = new Set(currentTools.map((t) => t.name));
          const existingToolNames = new Set(this._tools.map((t) => t.name));
          const changed = currentTools.length !== this._tools.length || [...currentToolNames].some((n) => !existingToolNames.has(n));
          if (changed) {
            logger.info(
              `\u{1F504} Tools changed before step ${stepNum + 1}, updating agent. New tools: ${[...currentToolNames].join(", ")}`
            );
            this._tools = currentTools;
            this._tools.push(...this.additionalTools);
            await this.createSystemMessageFromTools(this._tools);
            this._agentExecutor = this.createAgent();
            this._agentExecutor.maxIterations = steps;
            nameToToolMap = Object.fromEntries(this._tools.map((t) => [t.name, t]));
          }
        }
        logger.info(`\u{1F463} Step ${stepNum + 1}/${steps}`);
        try {
          logger.debug("Starting agent step execution");
          const nextStepOutput = await this._agentExecutor._takeNextStep(
            nameToToolMap,
            inputs,
            intermediateSteps,
            runManager
          );
          if ("returnValues" in nextStepOutput) {
            logger.info(`\u2705 Agent finished at step ${stepNum + 1}`);
            result = nextStepOutput.returnValues?.output ?? "No output generated";
            runManager?.handleChainEnd({ output: result });
            if (outputSchema && structuredLlm) {
              logger.info("\u{1F527} Attempting structured output...");
              const currentResult = result;
              this._attemptStructuredOutput(
                currentResult,
                this.llm,
                outputSchema
              ).then((structuredResult) => {
                if (this.memoryEnabled) {
                  this.addToHistory(new import_messages2.AIMessage(`Structured result: ${JSON.stringify(structuredResult)}`));
                }
                logger.info("\u2705 Structured output successful");
                structuredOutputSuccessRef.value = true;
                return structuredResult;
              }).catch((e) => {
                logger.warn(`\u26A0\uFE0F Structured output failed: ${e}`);
                const failedStructuredOutputPrompt = `
                The current result cannot be formatted into the required structure.
                Error: ${String(e)}
                
                Current information: ${currentResult}
                
                If information is missing, please continue working to gather the missing information needed for:
                ${schemaDescription}

                If the information is complete, please return the result in the required structure.
                `;
                inputs.input = failedStructuredOutputPrompt;
                if (this.memoryEnabled) {
                  this.addToHistory(new import_messages2.HumanMessage(failedStructuredOutputPrompt));
                }
                logger.info("\u{1F504} Continuing execution to gather missing information...");
              });
            }
          }
          if (Array.isArray(nextStepOutput)) {
            const stepArray = nextStepOutput;
            intermediateSteps.push(...stepArray);
            for (const step of stepArray) {
              yield step;
              const { action, observation } = step;
              const toolName = action.tool;
              toolsUsedNames.push(toolName);
              let toolInputStr = typeof action.toolInput === "string" ? action.toolInput : JSON.stringify(action.toolInput, null, 2);
              if (toolInputStr.length > 100)
                toolInputStr = `${toolInputStr.slice(0, 97)}...`;
              logger.info(`\u{1F527} Tool call: ${toolName} with input: ${toolInputStr}`);
              let outputStr = String(observation);
              if (outputStr.length > 100)
                outputStr = `${outputStr.slice(0, 97)}...`;
              outputStr = outputStr.replace(/\n/g, " ");
              logger.info(`\u{1F4C4} Tool result: ${outputStr}`);
            }
            if (stepArray.length) {
              const lastStep = stepArray[stepArray.length - 1];
              const toolReturn = await this._agentExecutor._getToolReturn(lastStep);
              if (toolReturn) {
                logger.info(`\u{1F3C6} Tool returned directly at step ${stepNum + 1}`);
                result = toolReturn.returnValues?.output ?? "No output generated";
                break;
              }
            }
          }
        } catch (e) {
          if (e instanceof import_output_parsers.OutputParserException) {
            logger.error(`\u274C Output parsing error during step ${stepNum + 1}: ${e}`);
            result = `Agent stopped due to a parsing error: ${e}`;
            runManager?.handleChainError(result);
            break;
          }
          logger.error(`\u274C Error during agent execution step ${stepNum + 1}: ${e}`);
          console.error(e);
          result = `Agent stopped due to an error: ${e}`;
          runManager?.handleChainError(result);
          break;
        }
      }
      if (!result) {
        logger.warn(`\u26A0\uFE0F Agent stopped after reaching max iterations (${steps})`);
        result = `Agent stopped after reaching the maximum number of steps (${steps}).`;
        runManager?.handleChainEnd({ output: result });
      }
      logger.info("\u{1F389} Agent execution complete");
      structuredOutputSuccessRef.value = true;
      return result;
    } catch (e) {
      logger.error(`\u274C Error running query: ${e}`);
      if (initializedHere && manageConnector) {
        logger.info("\u{1F9F9} Cleaning up resources after initialization error in run");
        await this.close();
      }
      throw e;
    } finally {
      const executionTimeMs = Date.now() - startTime;
      let serverCount = 0;
      if (this.client) {
        serverCount = Object.keys(this.client.getAllActiveSessions()).length;
      } else if (this.connectors) {
        serverCount = this.connectors.length;
      }
      const conversationHistoryLength = this.memoryEnabled ? this.conversationHistory.length : 0;
      await this.telemetry.trackAgentExecution({
        executionMethod: "stream",
        query,
        success: structuredOutputSuccess,
        modelProvider: this.modelProvider,
        modelName: this.modelName,
        serverCount,
        serverIdentifiers: this.connectors.map((connector) => connector.publicIdentifier),
        totalToolsAvailable: this._tools.length,
        toolsAvailableNames: this._tools.map((t) => t.name),
        maxStepsConfigured: this.maxSteps,
        memoryEnabled: this.memoryEnabled,
        useServerManager: this.useServerManager,
        maxStepsUsed: maxSteps ?? null,
        manageConnector,
        externalHistoryUsed: externalHistory !== void 0,
        stepsTaken,
        toolsUsedCount: toolsUsedNames.length,
        toolsUsedNames,
        response: result,
        executionTimeMs,
        errorType: structuredOutputSuccess ? null : "execution_error",
        conversationHistoryLength
      });
      if (manageConnector && !this.client && initializedHere) {
        logger.info("\u{1F9F9} Closing agent after query completion");
        await this.close();
      }
    }
  }
  async close() {
    if (this.isRemote && this.remoteAgent) {
      await this.remoteAgent.close();
      return;
    }
    logger.info("\u{1F50C} Closing MCPAgent resources\u2026");
    await this.observabilityManager.shutdown();
    try {
      this._agentExecutor = null;
      this._tools = [];
      if (this.client) {
        logger.info("\u{1F504} Closing sessions through client");
        await this.client.closeAllSessions();
        this.sessions = {};
      } else {
        for (const connector of this.connectors) {
          logger.info("\u{1F504} Disconnecting connector");
          await connector.disconnect();
        }
      }
      if ("connectorToolMap" in this.adapter) {
        this.adapter = new LangChainAdapter();
      }
    } finally {
      this._initialized = false;
      logger.info("\u{1F44B} Agent closed successfully");
    }
  }
  /**
   * Yields LangChain StreamEvent objects from the underlying streamEvents() method.
   * This provides token-level streaming and fine-grained event updates.
   */
  async *streamEvents(query, maxSteps, manageConnector = true, externalHistory, outputSchema) {
    let initializedHere = false;
    const startTime = Date.now();
    let success = false;
    let eventCount = 0;
    let totalResponseLength = 0;
    let finalResponse = "";
    if (outputSchema) {
      query = this._enhanceQueryWithSchema(query, outputSchema);
    }
    try {
      if (manageConnector && !this._initialized) {
        await this.initialize();
        initializedHere = true;
      } else if (!this._initialized && this.autoInitialize) {
        await this.initialize();
        initializedHere = true;
      }
      const agentExecutor = this.agentExecutor;
      if (!agentExecutor) {
        throw new Error("MCP agent failed to initialize");
      }
      const steps = maxSteps ?? this.maxSteps;
      agentExecutor.maxIterations = steps;
      const display_query = query.length > 50 ? `${query.slice(0, 50).replace(/\n/g, " ")}...` : query.replace(/\n/g, " ");
      logger.info(`\u{1F4AC} Received query for streamEvents: '${display_query}'`);
      if (this.memoryEnabled) {
        logger.info(`\u{1F504} Adding user message to history: ${query}`);
        this.addToHistory(new import_messages2.HumanMessage(query));
      }
      const historyToUse = externalHistory ?? this.conversationHistory;
      const langchainHistory = [];
      for (const msg of historyToUse) {
        if (msg instanceof import_messages2.HumanMessage || msg instanceof import_messages2.AIMessage || msg instanceof import_messages2.ToolMessage) {
          langchainHistory.push(msg);
        } else {
          logger.info(`\u26A0\uFE0F Skipped message of type: ${msg.constructor.name}`);
        }
      }
      const inputs = { input: query, chat_history: langchainHistory };
      logger.info("callbacks", this.callbacks);
      const eventStream = agentExecutor.streamEvents(
        inputs,
        {
          version: "v2",
          callbacks: this.callbacks.length > 0 ? this.callbacks : void 0
        }
      );
      for await (const event of eventStream) {
        eventCount++;
        if (!event || typeof event !== "object") {
          continue;
        }
        if (event.event === "on_chat_model_stream" && event.data?.chunk?.content) {
          totalResponseLength += event.data.chunk.content.length;
        }
        yield event;
        if (event.event === "on_chain_end" && event.data?.output) {
          const output = event.data.output;
          if (Array.isArray(output) && output.length > 0 && output[0]?.text) {
            finalResponse = output[0].text;
          } else if (typeof output === "string") {
            finalResponse = output;
          } else if (output && typeof output === "object" && "output" in output) {
            finalResponse = output.output;
          }
        }
      }
      if (outputSchema && finalResponse) {
        logger.info("\u{1F527} Attempting structured output conversion...");
        try {
          let conversionCompleted = false;
          let conversionResult = null;
          let conversionError = null;
          const _conversionPromise = this._attemptStructuredOutput(
            finalResponse,
            this.llm,
            outputSchema
          ).then((result) => {
            conversionCompleted = true;
            conversionResult = result;
            return result;
          }).catch((error) => {
            conversionCompleted = true;
            conversionError = error;
            throw error;
          });
          let progressCount = 0;
          while (!conversionCompleted) {
            await new Promise((resolve) => setTimeout(resolve, 2e3));
            if (!conversionCompleted) {
              progressCount++;
              yield {
                event: "on_structured_output_progress",
                data: {
                  message: `Converting to structured output... (${progressCount * 2}s)`,
                  elapsed: progressCount * 2
                }
              };
            }
          }
          if (conversionError) {
            throw conversionError;
          }
          if (conversionResult) {
            yield {
              event: "on_structured_output",
              data: { output: conversionResult }
            };
            if (this.memoryEnabled) {
              this.addToHistory(new import_messages2.AIMessage(`Structured result: ${JSON.stringify(conversionResult)}`));
            }
            logger.info("\u2705 Structured output successful");
          }
        } catch (e) {
          logger.warn(`\u26A0\uFE0F Structured output failed: ${e}`);
          yield {
            event: "on_structured_output_error",
            data: { error: e instanceof Error ? e.message : String(e) }
          };
        }
      } else if (this.memoryEnabled && finalResponse) {
        this.addToHistory(new import_messages2.AIMessage(finalResponse));
      }
      logger.info(`\u{1F389} StreamEvents complete - ${eventCount} events emitted`);
      success = true;
    } catch (e) {
      logger.error(`\u274C Error during streamEvents: ${e}`);
      if (initializedHere && manageConnector) {
        logger.info("\u{1F9F9} Cleaning up resources after initialization error in streamEvents");
        await this.close();
      }
      throw e;
    } finally {
      const executionTimeMs = Date.now() - startTime;
      let serverCount = 0;
      if (this.client) {
        serverCount = Object.keys(this.client.getAllActiveSessions()).length;
      } else if (this.connectors) {
        serverCount = this.connectors.length;
      }
      const conversationHistoryLength = this.memoryEnabled ? this.conversationHistory.length : 0;
      await this.telemetry.trackAgentExecution({
        executionMethod: "streamEvents",
        query,
        success,
        modelProvider: this.modelProvider,
        modelName: this.modelName,
        serverCount,
        serverIdentifiers: this.connectors.map((connector) => connector.publicIdentifier),
        totalToolsAvailable: this._tools.length,
        toolsAvailableNames: this._tools.map((t) => t.name),
        maxStepsConfigured: this.maxSteps,
        memoryEnabled: this.memoryEnabled,
        useServerManager: this.useServerManager,
        maxStepsUsed: maxSteps ?? null,
        manageConnector,
        externalHistoryUsed: externalHistory !== void 0,
        response: `[STREAMED RESPONSE - ${totalResponseLength} chars]`,
        executionTimeMs,
        errorType: success ? null : "streaming_error",
        conversationHistoryLength
      });
      if (manageConnector && !this.client && initializedHere) {
        logger.info("\u{1F9F9} Closing agent after streamEvents completion");
        await this.close();
      }
    }
  }
  /**
   * Attempt to create structured output from raw result with validation and retry logic.
   */
  async _attemptStructuredOutput(rawResult, llm, outputSchema) {
    logger.info(`\u{1F504} Attempting structured output with schema: ${outputSchema}`);
    logger.info(`\u{1F504} Raw result: ${JSON.stringify(rawResult, null, 2)}`);
    let structuredLlm = null;
    let schemaDescription = "";
    logger.debug(`\u{1F504} Structured output requested, schema: ${JSON.stringify((0, import_zod_to_json_schema2.zodToJsonSchema)(outputSchema), null, 2)}`);
    if (llm && "withStructuredOutput" in llm && typeof llm.withStructuredOutput === "function") {
      structuredLlm = llm.withStructuredOutput(outputSchema);
    } else if (llm) {
      structuredLlm = llm;
    } else {
      throw new Error("LLM is required for structured output");
    }
    schemaDescription = JSON.stringify((0, import_zod_to_json_schema2.zodToJsonSchema)(outputSchema), null, 2);
    logger.info(`\u{1F504} Schema description: ${schemaDescription}`);
    let textContent = "";
    if (typeof rawResult === "string") {
      textContent = rawResult;
    } else if (rawResult && typeof rawResult === "object") {
      textContent = JSON.stringify(rawResult);
    }
    if (!textContent) {
      textContent = JSON.stringify(rawResult);
    }
    const maxRetries = 3;
    let lastError = "";
    for (let attempt = 1; attempt <= maxRetries; attempt++) {
      logger.info(`\u{1F504} Structured output attempt ${attempt}/${maxRetries}`);
      let formatPrompt = `
      Please format the following information according to the EXACT schema specified below.
      You must use the exact field names and types as shown in the schema.
      
      Required schema format:
      ${schemaDescription}
      
      Content to extract from:
      ${textContent}
      
      IMPORTANT: 
      - Use ONLY the field names specified in the schema
      - Match the data types exactly (string, number, boolean, array, etc.)
      - Include ALL required fields
      - Return valid JSON that matches the schema structure exactly
      `;
      if (attempt > 1) {
        formatPrompt += `
        
        PREVIOUS ATTEMPT FAILED with error: ${lastError}
        Please fix the issues mentioned above and ensure the output matches the schema exactly.
        `;
      }
      try {
        logger.info(`\u{1F504} Structured output attempt ${attempt} - using streaming approach`);
        const stream = await structuredLlm.stream(formatPrompt);
        let structuredResult = null;
        let chunkCount = 0;
        for await (const chunk of stream) {
          chunkCount++;
          logger.info(`Chunk ${chunkCount}: ${JSON.stringify(chunk, null, 2)}`);
          if (typeof chunk === "string") {
            try {
              structuredResult = JSON.parse(chunk);
            } catch (e) {
              logger.warn(`\u{1F504} Failed to parse string chunk as JSON: ${chunk}`);
            }
          } else if (chunk && typeof chunk === "object") {
            structuredResult = chunk;
          } else {
            try {
              structuredResult = JSON.parse(String(chunk));
            } catch (e) {
              logger.warn(`\u{1F504} Failed to parse chunk as JSON: ${chunk}`);
            }
          }
          if (chunkCount % 10 === 0) {
            logger.info(`\u{1F504} Structured output streaming: ${chunkCount} chunks`);
          }
        }
        logger.info(`\u{1F504} Structured result attempt ${attempt}: ${JSON.stringify(structuredResult, null, 2)}`);
        if (!structuredResult) {
          throw new Error("No structured result received from stream");
        }
        const validatedResult = this._validateStructuredResult(structuredResult, outputSchema);
        logger.info(`\u2705 Structured output successful on attempt ${attempt}`);
        return validatedResult;
      } catch (e) {
        lastError = e instanceof Error ? e.message : String(e);
        logger.warn(`\u26A0\uFE0F Structured output attempt ${attempt} failed: ${lastError}`);
        if (attempt === maxRetries) {
          logger.error(`\u274C All ${maxRetries} structured output attempts failed`);
          throw new Error(`Failed to generate valid structured output after ${maxRetries} attempts. Last error: ${lastError}`);
        }
        continue;
      }
    }
    throw new Error("Unexpected error in structured output generation");
  }
  /**
   * Validate the structured result against the schema with detailed error reporting
   */
  _validateStructuredResult(structuredResult, outputSchema) {
    try {
      const validatedResult = outputSchema.parse(structuredResult);
      const schemaType = outputSchema;
      if (schemaType._def && schemaType._def.shape) {
        for (const [fieldName, fieldSchema] of Object.entries(schemaType._def.shape)) {
          const field = fieldSchema;
          const isOptional = field.isOptional?.() ?? field._def?.typeName === "ZodOptional";
          const isNullable = field.isNullable?.() ?? field._def?.typeName === "ZodNullable";
          if (!isOptional && !isNullable) {
            const value = validatedResult[fieldName];
            if (value === null || value === void 0 || typeof value === "string" && !value.trim() || Array.isArray(value) && value.length === 0) {
              throw new Error(`Required field '${fieldName}' is missing or empty`);
            }
          }
        }
      }
      return validatedResult;
    } catch (e) {
      logger.debug(`Validation details: ${e}`);
      throw e;
    }
  }
  /**
   * Enhance the query with schema information to make the agent aware of required fields.
   */
  _enhanceQueryWithSchema(query, outputSchema) {
    try {
      const schemaDescription = JSON.stringify((0, import_zod_to_json_schema2.zodToJsonSchema)(outputSchema), null, 2);
      const enhancedQuery = `
      ${query}
      
      IMPORTANT: Your response must include sufficient information to populate the following structured output:
      
      ${schemaDescription}
      
      Make sure you gather ALL the required information during your task execution.
      If any required information is missing, continue working to find it.
      `;
      return enhancedQuery;
    } catch (e) {
      logger.warn(`Could not extract schema details: ${e}`);
      return query;
    }
  }
};

// src/auth/browser-provider.ts
var import_strict_url_sanitise = require("strict-url-sanitise");
var BrowserOAuthClientProvider = class {
  static {
    __name(this, "BrowserOAuthClientProvider");
  }
  serverUrl;
  storageKeyPrefix;
  serverUrlHash;
  clientName;
  clientUri;
  callbackUrl;
  preventAutoAuth;
  onPopupWindow;
  constructor(serverUrl, options = {}) {
    this.serverUrl = serverUrl;
    this.storageKeyPrefix = options.storageKeyPrefix || "mcp:auth";
    this.serverUrlHash = this.hashString(serverUrl);
    this.clientName = options.clientName || "mcp-use";
    this.clientUri = options.clientUri || (typeof window !== "undefined" ? window.location.origin : "");
    this.callbackUrl = (0, import_strict_url_sanitise.sanitizeUrl)(
      options.callbackUrl || (typeof window !== "undefined" ? new URL("/oauth/callback", window.location.origin).toString() : "/oauth/callback")
    );
    this.preventAutoAuth = options.preventAutoAuth;
    this.onPopupWindow = options.onPopupWindow;
  }
  // --- SDK Interface Methods ---
  get redirectUrl() {
    return (0, import_strict_url_sanitise.sanitizeUrl)(this.callbackUrl);
  }
  get clientMetadata() {
    return {
      redirect_uris: [this.redirectUrl],
      token_endpoint_auth_method: "none",
      // Public client
      grant_types: ["authorization_code", "refresh_token"],
      response_types: ["code"],
      client_name: this.clientName,
      client_uri: this.clientUri
      // scope: 'openid profile email mcp', // Example scopes, adjust as needed
    };
  }
  async clientInformation() {
    const key = this.getKey("client_info");
    const data = localStorage.getItem(key);
    if (!data) return void 0;
    try {
      return JSON.parse(data);
    } catch (e) {
      console.warn(`[${this.storageKeyPrefix}] Failed to parse client information:`, e);
      localStorage.removeItem(key);
      return void 0;
    }
  }
  // NOTE: The SDK's auth() function uses this if dynamic registration is needed.
  // Ensure your OAuthClientInformationFull matches the expected structure if DCR is used.
  async saveClientInformation(clientInformation) {
    const key = this.getKey("client_info");
    localStorage.setItem(key, JSON.stringify(clientInformation));
  }
  async tokens() {
    const key = this.getKey("tokens");
    const data = localStorage.getItem(key);
    if (!data) return void 0;
    try {
      return JSON.parse(data);
    } catch (e) {
      console.warn(`[${this.storageKeyPrefix}] Failed to parse tokens:`, e);
      localStorage.removeItem(key);
      return void 0;
    }
  }
  async saveTokens(tokens) {
    const key = this.getKey("tokens");
    localStorage.setItem(key, JSON.stringify(tokens));
    localStorage.removeItem(this.getKey("code_verifier"));
    localStorage.removeItem(this.getKey("last_auth_url"));
  }
  async saveCodeVerifier(codeVerifier) {
    const key = this.getKey("code_verifier");
    localStorage.setItem(key, codeVerifier);
  }
  async codeVerifier() {
    const key = this.getKey("code_verifier");
    const verifier = localStorage.getItem(key);
    if (!verifier) {
      throw new Error(
        `[${this.storageKeyPrefix}] Code verifier not found in storage for key ${key}. Auth flow likely corrupted or timed out.`
      );
    }
    return verifier;
  }
  /**
   * Generates and stores the authorization URL with state, without opening a popup.
   * Used when preventAutoAuth is enabled to provide the URL for manual navigation.
   * @param authorizationUrl The fully constructed authorization URL from the SDK.
   * @returns The full authorization URL with state parameter.
   */
  async prepareAuthorizationUrl(authorizationUrl) {
    const state = globalThis.crypto.randomUUID();
    const stateKey = `${this.storageKeyPrefix}:state_${state}`;
    const stateData = {
      serverUrlHash: this.serverUrlHash,
      expiry: Date.now() + 1e3 * 60 * 10,
      // State expires in 10 minutes
      // Store provider options needed to reconstruct on callback
      providerOptions: {
        serverUrl: this.serverUrl,
        storageKeyPrefix: this.storageKeyPrefix,
        clientName: this.clientName,
        clientUri: this.clientUri,
        callbackUrl: this.callbackUrl
      }
    };
    localStorage.setItem(stateKey, JSON.stringify(stateData));
    authorizationUrl.searchParams.set("state", state);
    const authUrlString = authorizationUrl.toString();
    const sanitizedAuthUrl = (0, import_strict_url_sanitise.sanitizeUrl)(authUrlString);
    localStorage.setItem(this.getKey("last_auth_url"), sanitizedAuthUrl);
    return sanitizedAuthUrl;
  }
  /**
   * Redirects the user agent to the authorization URL, storing necessary state.
   * This now adheres to the SDK's void return type expectation for the interface.
   * @param authorizationUrl The fully constructed authorization URL from the SDK.
   */
  async redirectToAuthorization(authorizationUrl) {
    if (this.preventAutoAuth) return;
    const sanitizedAuthUrl = await this.prepareAuthorizationUrl(authorizationUrl);
    const popupFeatures = "width=600,height=700,resizable=yes,scrollbars=yes,status=yes";
    try {
      const popup = window.open(sanitizedAuthUrl, `mcp_auth_${this.serverUrlHash}`, popupFeatures);
      if (this.onPopupWindow) {
        this.onPopupWindow(sanitizedAuthUrl, popupFeatures, popup);
      }
      if (!popup || popup.closed || typeof popup.closed === "undefined") {
        console.warn(
          `[${this.storageKeyPrefix}] Popup likely blocked by browser. Manual navigation might be required using the stored URL.`
        );
      } else {
        popup.focus();
        console.info(`[${this.storageKeyPrefix}] Redirecting to authorization URL in popup.`);
      }
    } catch (e) {
      console.error(`[${this.storageKeyPrefix}] Error opening popup window:`, e);
    }
  }
  // --- Helper Methods ---
  /**
   * Retrieves the last URL passed to `redirectToAuthorization`. Useful for manual fallback.
   */
  getLastAttemptedAuthUrl() {
    const storedUrl = localStorage.getItem(this.getKey("last_auth_url"));
    return storedUrl ? (0, import_strict_url_sanitise.sanitizeUrl)(storedUrl) : null;
  }
  clearStorage() {
    const prefixPattern = `${this.storageKeyPrefix}_${this.serverUrlHash}_`;
    const statePattern = `${this.storageKeyPrefix}:state_`;
    const keysToRemove = [];
    let count = 0;
    for (let i = 0; i < localStorage.length; i++) {
      const key = localStorage.key(i);
      if (!key) continue;
      if (key.startsWith(prefixPattern)) {
        keysToRemove.push(key);
      } else if (key.startsWith(statePattern)) {
        try {
          const item = localStorage.getItem(key);
          if (item) {
            const state = JSON.parse(item);
            if (state.serverUrlHash === this.serverUrlHash) {
              keysToRemove.push(key);
            }
          }
        } catch (e) {
          console.warn(`[${this.storageKeyPrefix}] Error parsing state key ${key} during clearStorage:`, e);
        }
      }
    }
    const uniqueKeysToRemove = [...new Set(keysToRemove)];
    uniqueKeysToRemove.forEach((key) => {
      localStorage.removeItem(key);
      count++;
    });
    return count;
  }
  hashString(str) {
    let hash = 0;
    for (let i = 0; i < str.length; i++) {
      const char = str.charCodeAt(i);
      hash = (hash << 5) - hash + char;
      hash = hash & hash;
    }
    return Math.abs(hash).toString(16);
  }
  getKey(keySuffix) {
    return `${this.storageKeyPrefix}_${this.serverUrlHash}_${keySuffix}`;
  }
};

// src/auth/callback.ts
var import_auth = require("@modelcontextprotocol/sdk/client/auth.js");
async function onMcpAuthorization() {
  const queryParams = new URLSearchParams(window.location.search);
  const code = queryParams.get("code");
  const state = queryParams.get("state");
  const error = queryParams.get("error");
  const errorDescription = queryParams.get("error_description");
  const logPrefix = "[mcp-callback]";
  console.log(`${logPrefix} Handling callback...`, { code, state, error, errorDescription });
  let provider = null;
  let storedStateData = null;
  const stateKey = state ? `mcp:auth:state_${state}` : null;
  try {
    if (error) {
      throw new Error(`OAuth error: ${error} - ${errorDescription || "No description provided."}`);
    }
    if (!code) {
      throw new Error("Authorization code not found in callback query parameters.");
    }
    if (!state || !stateKey) {
      throw new Error("State parameter not found or invalid in callback query parameters.");
    }
    const storedStateJSON = localStorage.getItem(stateKey);
    if (!storedStateJSON) {
      throw new Error(`Invalid or expired state parameter "${state}". No matching state found in storage.`);
    }
    try {
      storedStateData = JSON.parse(storedStateJSON);
    } catch (e) {
      throw new Error("Failed to parse stored OAuth state.");
    }
    if (!storedStateData.expiry || storedStateData.expiry < Date.now()) {
      localStorage.removeItem(stateKey);
      throw new Error("OAuth state has expired. Please try initiating authentication again.");
    }
    if (!storedStateData.providerOptions) {
      throw new Error("Stored state is missing required provider options.");
    }
    const { serverUrl, ...providerOptions } = storedStateData.providerOptions;
    console.log(`${logPrefix} Re-instantiating provider for server: ${serverUrl}`);
    provider = new BrowserOAuthClientProvider(serverUrl, providerOptions);
    console.log(`${logPrefix} Calling SDK auth() to exchange code...`);
    const baseUrl = new URL(serverUrl).origin;
    const authResult = await (0, import_auth.auth)(provider, { serverUrl: baseUrl, authorizationCode: code });
    if (authResult === "AUTHORIZED") {
      console.log(`${logPrefix} Authorization successful via SDK auth(). Notifying opener...`);
      if (window.opener && !window.opener.closed) {
        window.opener.postMessage({ type: "mcp_auth_callback", success: true }, window.location.origin);
        window.close();
      } else {
        console.warn(`${logPrefix} No opener window detected. Redirecting to root.`);
        const pathParts = window.location.pathname.split("/").filter(Boolean);
        const basePath = pathParts.length > 0 && pathParts[pathParts.length - 1] === "callback" ? "/" + pathParts.slice(0, -2).join("/") : "/";
        window.location.href = basePath || "/";
      }
      localStorage.removeItem(stateKey);
    } else {
      console.warn(`${logPrefix} SDK auth() returned unexpected status: ${authResult}`);
      throw new Error(`Unexpected result from authentication library: ${authResult}`);
    }
  } catch (err) {
    console.error(`${logPrefix} Error during OAuth callback handling:`, err);
    const errorMessage = err instanceof Error ? err.message : String(err);
    if (window.opener && !window.opener.closed) {
      window.opener.postMessage({ type: "mcp_auth_callback", success: false, error: errorMessage }, window.location.origin);
    }
    try {
      document.body.innerHTML = `
            <div style="font-family: sans-serif; padding: 20px;">
            <h1>Authentication Error</h1>
            <p style="color: red; background-color: #ffebeb; border: 1px solid red; padding: 10px; border-radius: 4px;">
                ${errorMessage}
            </p>
            <p>You can close this window or <a href="#" onclick="window.close(); return false;">click here to close</a>.</p>
            <pre style="font-size: 0.8em; color: #555; margin-top: 20px; white-space: pre-wrap;">${err instanceof Error ? err.stack : ""}</pre>
            </div>
        `;
    } catch (displayError) {
      console.error(`${logPrefix} Could not display error in callback window:`, displayError);
    }
    if (stateKey) {
      localStorage.removeItem(stateKey);
    }
    if (provider) {
      localStorage.removeItem(provider.getKey("code_verifier"));
      localStorage.removeItem(provider.getKey("last_auth_url"));
    }
  }
}
__name(onMcpAuthorization, "onMcpAuthorization");

// src/browser.ts
init_logging();

// src/agents/utils/ai_sdk.ts
async function* streamEventsToAISDK(streamEvents) {
  for await (const event of streamEvents) {
    if (event.event === "on_chat_model_stream" && event.data?.chunk?.text) {
      const textContent = event.data.chunk.text;
      if (typeof textContent === "string" && textContent.length > 0) {
        yield textContent;
      }
    }
  }
}
__name(streamEventsToAISDK, "streamEventsToAISDK");
function createReadableStreamFromGenerator(generator) {
  return new ReadableStream({
    async start(controller) {
      try {
        for await (const chunk of generator) {
          controller.enqueue(chunk);
        }
        controller.close();
      } catch (error) {
        controller.error(error);
      }
    }
  });
}
__name(createReadableStreamFromGenerator, "createReadableStreamFromGenerator");
async function* streamEventsToAISDKWithTools(streamEvents) {
  for await (const event of streamEvents) {
    switch (event.event) {
      case "on_chat_model_stream":
        if (event.data?.chunk?.text) {
          const textContent = event.data.chunk.text;
          if (typeof textContent === "string" && textContent.length > 0) {
            yield textContent;
          }
        }
        break;
      case "on_tool_start":
        yield `
\u{1F527} Using tool: ${event.name}
`;
        break;
      case "on_tool_end":
        yield `
\u2705 Tool completed: ${event.name}
`;
        break;
      default:
        break;
    }
  }
}
__name(streamEventsToAISDKWithTools, "streamEventsToAISDKWithTools");

// src/browser.ts
var import_messages3 = require("@langchain/core/messages");
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
  AIMessage,
  BaseAdapter,
  BaseConnector,
  BaseMessage,
  BrowserOAuthClientProvider,
  HttpConnector,
  HumanMessage,
  LangChainAdapter,
  Logger,
  MCPAgent,
  MCPClient,
  MCPSession,
  ObservabilityManager,
  RemoteAgent,
  SystemMessage,
  ToolMessage,
  WebSocketConnector,
  createReadableStreamFromGenerator,
  logger,
  onMcpAuthorization,
  streamEventsToAISDK,
  streamEventsToAISDKWithTools
});
