/**
 * OAuth helper for browser-based MCP authentication
 *
 * This helper provides OAuth 2.0 authorization code flow support for MCP servers
 * that require authentication, such as Linear's MCP server.
 */
export interface OAuthConfig {
    clientId?: string;
    redirectUri: string;
    scope?: string;
    state?: string;
    clientName?: string;
}
export interface OAuthDiscovery {
    issuer: string;
    authorization_endpoint: string;
    token_endpoint: string;
    registration_endpoint?: string;
    response_types_supported: string[];
    grant_types_supported: string[];
    code_challenge_methods_supported: string[];
    token_endpoint_auth_methods_supported?: string[];
}
export interface ClientRegistration {
    client_id: string;
    client_secret?: string;
    registration_access_token?: string;
    registration_client_uri?: string;
    client_id_issued_at?: number;
    client_secret_expires_at?: number;
}
export interface OAuthResult {
    access_token: string;
    token_type: string;
    expires_at?: number | null;
    refresh_token?: string | null;
    scope?: string | null;
}
export interface OAuthState {
    isRequired: boolean;
    isAuthenticated: boolean;
    isAuthenticating: boolean;
    isCompletingOAuth: boolean;
    authError: string | null;
    oauthTokens: OAuthResult | null;
}
export declare class OAuthHelper {
    private config;
    private discovery?;
    private state;
    private clientRegistration?;
    constructor(config: OAuthConfig);
    /**
     * Get current OAuth state
     */
    getState(): OAuthState;
    /**
     * Check if a server requires authentication by pinging the URL
     */
    checkAuthRequired(serverUrl: string): Promise<boolean>;
    /**
     * Fallback heuristics for determining auth requirements when direct checking fails
     */
    private checkAuthByHeuristics;
    /**
     * Discover OAuth configuration from a server
     */
    discoverOAuthConfig(serverUrl: string): Promise<OAuthDiscovery | undefined>;
    /**
     * Register a new OAuth client dynamically
     */
    registerClient(_serverUrl: string): Promise<ClientRegistration>;
    /**
     * Generate authorization URL for OAuth flow
     */
    generateAuthUrl(serverUrl: string, additionalParams?: Record<string, string>): string;
    /**
     * Exchange authorization code for access token
     */
    exchangeCodeForToken(serverUrl: string, code: string, codeVerifier?: string): Promise<OAuthResult>;
    /**
     * Handle OAuth callback and extract authorization code
     */
    handleCallback(): {
        code: string;
        state: string;
    } | null;
    /**
     * Start OAuth flow by opening popup window (similar to your implementation)
     */
    startOAuthFlow(serverUrl: string): Promise<void>;
    /**
     * Complete OAuth flow by exchanging code for token
     */
    completeOAuthFlow(serverUrl: string, code: string): Promise<OAuthResult>;
    /**
     * Reset authentication state
     */
    resetAuth(): void;
    /**
     * Set OAuth state (internal method)
     */
    private setState;
    /**
     * Generate a random state parameter for CSRF protection
     */
    private generateState;
}
/**
 * Linear-specific OAuth configuration
 */
export declare const LINEAR_OAUTH_CONFIG: OAuthConfig;
/**
 * Helper function to create OAuth-enabled MCP configuration
 */
export declare function createOAuthMCPConfig(serverUrl: string, accessToken: string): {
    mcpServers: {
        linear: {
            url: string;
            authToken: string;
            transport: string;
        };
    };
};
//# sourceMappingURL=oauth-helper.d.ts.map